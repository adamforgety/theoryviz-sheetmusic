<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TheoryViz</title>
    <meta name="theme-color" content="#3b82f6">
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.0.3/build/cjs/vexflow.js"></script>
    
    <style>
        /* Custom styles for the SVG keyboard container */
        .keyboard-container {
            position: relative;
            /* Height remains 250px to accommodate the step visualizer track */
            height: 250px; 
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            /* Light gray for contrast against the white keys */
            background-color: #f3f4f6;
            overflow-x: scroll; /* KEEP scroll to allow the fixed width content to be scrolled */
            overscroll-behavior: contain; /* Prevents unwanted browser scroll on mobile drag */
        }

        /* Hide scrollbar for a cleaner look, while still allowing scroll */
        .keyboard-container::-webkit-scrollbar {
            display: none;
        }
        .keyboard-container {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* Highlighting Styles for a consistent look with the buttons */
        .highlight-transition {
            transition: fill 0.2s ease;
        }
        
        /* Custom style for visualization buttons (Removed .active style to use pure Tailwind in JS) */
        .viz-btn {
            border-radius: 0.5rem;
            transition: all 0.2s;
            font-weight: 600; /* font-semibold */
            padding-top: 0.625rem; /* py-2.5 */
            padding-bottom: 0.625rem; /* py-2.5 */
            border-width: 1px; /* Ensure border is present for both states */
        }
        
        /* Style the VexFlow container to ensure it looks good */
        /* Set a height for the single staff container */
        #staff-display-single {
            min-height: 140px; 
        }
        
        /* Ensures the canvas/svg element from VexFlow doesn't look bad */
        #staff-display-single > svg {
            display: block;
            margin: 0 auto;
        }

    </style>
</head>
<body class="bg-gray-50 font-sans p-8"> 
    <div class="max-w-6xl mx-auto bg-white rounded-xl shadow-2xl p-10"> 
        <h1 class="text-4xl font-extrabold text-gray-800 mb-3 text-center"> TheoryViz
        </h1>
        <p class="text-center text-gray-600 mb-6">
            Visualize harmony anywhere!
        </p>

        <div class="p-4 bg-gray-100 rounded-xl mb-6 shadow-inner border border-gray-200">
            <div class="grid grid-cols-2 gap-4"> 
            
                <div>
                    <label for="key-select" class="block text-xs font-medium text-gray-700 mb-1">Root Key</label>
                    <select id="key-select" onchange="handleKeyChange(event.target.value)"
                            class="w-full p-2 border border-gray-300 rounded-lg bg-white text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                        </select>
                </div>

                <div>
                    <label for="mode-select" class="block text-xs font-medium text-gray-700 mb-1">Scale Type</label>
                    <select id="mode-select" onchange="handleModeChange(event.target.value)"
                            class="w-full p-2 border border-gray-300 rounded-lg bg-white text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                        </select>
                </div>

                <button id="mode-chord-btn" onclick="handleVisualizationModeChange('chord')"
                        class="viz-btn w-full text-base"> Chord View
                </button>
                
                <button id="mode-scale-btn" onclick="handleVisualizationModeChange('scale')"
                        class="viz-btn w-full text-base"> Scale View
                </button>
            </div>
            
            <div id="accidental-switch-container" class="mt-4 pt-4 border-t border-gray-300">
                <label class="block text-xs font-medium text-gray-700 mb-2">Accidental Preference (for chromatic/C keys)</label>
            </div>
            </div>
        
        <div class="grid grid-cols-1 lg:grid-cols-1 gap-4 mb-6">
            
            <div id="sheet-music-container" class="p-4 bg-gray-100 border border-gray-300 rounded-xl shadow-inner">
                <div class="flex flex-col justify-between items-start mb-3 border-b pb-2"> 
                    <h2 id="staff-header-text" class="text-lg font-bold text-gray-800 mb-2"> </h2> 
                    <div class="flex items-center space-x-3">
                        <label for="clef-select" class="text-sm text-gray-700 font-medium">Clef:</label>
                        <select id="clef-select" onchange="handleClefChange(event.target.value)"
                                class="p-1 border border-gray-300 rounded-lg bg-white text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                            <option value="treble">Treble</option>
                            <option value="bass">Bass</option>
                        </select>
                    </div>
                </div>
                <div id="staff-display-single" class="w-full overflow-x-scroll min-h-[140px]">
                </div>
            </div>

        </div>
        
        <div id="piano-container" class="keyboard-container overflow-x-scroll pb-4 mt-4">
            <div id="step-visualizer-track" style="width: 1320px; position: relative; height: 30px;" class="mt-1 mb-1">
                </div>
            <svg id="piano-keyboard-svg" width="100%" height="200" preserveAspectRatio="xMinYMin slice"></svg>
        </div>
        
        <div class="mt-4 mb-6 py-3 px-4 bg-yellow-100 border-2 border-yellow-400 text-yellow-800 text-sm rounded-lg text-center font-bold shadow-md">
            Click the <span class="text-blue-700 font-extrabold">ACTIVE</span> Roman numeral to cycle <span class="text-indigo-700">INVERSIONS</span> (Root, 1st, 2st) in Chord View.
        </div>

        <div id="chord-buttons-container" class="grid grid-cols-8 gap-3"> </div>
        
    </div>

    <script>
        // --- VEXFLOW ALIASES (New) ---
        const { Renderer, Stave, StaveNote, Voice, Formatter, Accidental } = Vex.Flow;

        // --- CONSTANTS AND MAPPING ---
        
        // Expanded list of key names for the dropdown
        const KEY_DISPLAY_NAMES = [
            "C", "C#", "Db", "D", "D#", "Eb", "E", 
            "F", "F#", "Gb", "G", "G#", "Ab", "A", 
            "A#", "Bb", "B"
        ];
        
        // Map to link display name back to the 0-11 pitch class (C=0, C#=1, Db=1, etc.)
        const KEY_TO_PITCH_CLASS = {
            "C": 0, "C#": 1, "Db": 1, "D": 2, "D#": 3, "Eb": 3, "E": 4, 
            "F": 5, "F#": 6, "Gb": 6, "G": 7, "G#": 8, "Ab": 8, "A": 9, 
            "A#": 10, "Bb": 10, "B": 11
        };
        // Sharp-based names (C, C#, D, D#, ...) - Used for default internal logic and non-flat keys
        const KEYS = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        
        // Flat-based names (C, Db, D, Eb, ...) - Used for VexFlow note string generation in flat keys
        const FLAT_KEYS = ["c", "db", "d", "eb", "e", "f", "gb", "g", "ab", "a", "bb", "b"];
        // Sharp-based names (c, c#, d, d#, ...) - Used for VexFlow note string generation in sharp keys
        const SHARP_KEYS = ["c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b"];
        
        // Helpers for Key Signature logic (NEW)
        const SHARP_KEYS_ORDER = ['F', 'C', 'G', 'D', 'A', 'E', 'B'];
        const FLAT_KEYS_ORDER = ['B', 'E', 'A', 'D', 'G', 'C', 'F'];
        
        // Flat root keys that mandate flat spelling for the staff
        const FLAT_ROOT_KEYS = ['Db', 'Eb', 'Gb', 'Ab', 'Bb']; 

        const MAJOR_INTERVALS = [0, 2, 4, 5, 7, 9, 11]; 
        
        // VexFlow Key Signature Map 
        const KEY_SIGNATURE_MAP = [
            'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'
        ];

        const SCALE_MODES = {
            'major': {
                name: 'Ionian (Major)',
                intervals: [0, 2, 4, 5, 7, 9, 11],
                steps: ["W", "W", "H", "W", "W", "W", "H"],
                triadQualities: ["Maj", "min", "min", "Maj", "Maj", "min", "dim", "Maj"], 
                qualities: ["I", "ii", "iii", "IV", "V", "vi", "vii째", "VIII (I)"], 
                chordSteps: [0, 2, 4], 
                degrees: 8, 
                isDiatonic: true
            },
            'natural_minor': {
                name: 'Aeolian (Natural Minor)',
                intervals: [0, 2, 3, 5, 7, 8, 10],
                steps: ["W", "H", "W", "W", "H", "W", "W"],
                triadQualities: ["min", "dim", "Maj", "min", "min", "Maj", "Maj", "min"],
                qualities: ["i", "ii째", "III", "iv", "v", "VI", "VII", "viii (i)"],
                chordSteps: [0, 2, 4],
                degrees: 8,
                isDiatonic: true
            },
            'harmonic_minor': {
                name: 'Harmonic Minor',
                intervals: [0, 2, 3, 5, 7, 8, 11], 
                steps: ["W", "H", "W", "W", "H", "1.5", "H"], 
                triadQualities: ["min", "dim", "Aug", "min", "Maj", "Maj", "dim", "min"], 
                qualities: ["i", "ii째", "III+", "iv", "V", "VI", "vii째", "viii (i)"],
                chordSteps: [0, 2, 4],
                degrees: 8, 
                isDiatonic: true
            },
            'major_pentatonic': {
                name: 'Major Pentatonic',
                intervals: [0, 2, 4, 7, 9],
                steps: ["W", "W", "1.5", "W", "1.5"], 
                triadQualities: ["", "", "", "", ""], 
                qualities: ["1", "2", "3", "4", "5"], 
                chordSteps: [0], 
                degrees: 5,
                isDiatonic: false
            },
            'minor_pentatonic': {
                name: 'Minor Pentatonic',
                intervals: [0, 3, 5, 7, 10],
                steps: ["1.5", "W", "W", "1.5", "W"],
                triadQualities: ["", "", "", "", ""],
                qualities: ["1", "2", "3", "4", "5"], 
                chordSteps: [0],
                degrees: 5,
                isDiatonic: false
            }
        };
        
        // MIDI note range updated: B3 (59) to B6 (95) - 37 keys total
        const START_MIDI = 59; // B3
        const END_MIDI = 95;   // B6 
        
        // --- SVG KEYBOARD CONFIGURATION ---
        const KEYBOARD_CONFIG = {
            TOTAL_KEYS_RANGE: END_MIDI - START_MIDI + 1, // 37 keys
            WHITE_KEYS_COUNT: 22, // B3, C4, D4, E4, F4, G4, A4, B4, C5, ... B6
            KEYBOARD_WIDTH: 1320, // 22 white keys * 60px/key
            KEYBOARD_HEIGHT: 200,
            KEY_Y_START: 10,
            WHITE_KEY_HEIGHT: 180,
            WHITE_KEY_WIDTH: 1320 / 22, // 60px
            BLACK_KEY_WIDTH: (1320 / 22) * 0.6, // 36px
            BLACK_KEY_HEIGHT: 110,
        };

        const KEY_COLORS = {
            WHITE: '#ffffff',
            BLACK: '#1f2937',
            HIGHLIGHT_WHITE: '#3b82f6',     // Blue for Root/Scale
            HIGHLIGHT_BLACK: '#2563eb',     // Darker Blue for Root/Scale
            
            // Inverted colors (matching the indigo button)
            INVERTED_HIGHLIGHT_WHITE: '#4f46e5', // Indigo-600
            INVERTED_HIGHLIGHT_BLACK: '#4338ca'  // Indigo-700
        };
        
        const PIANO_KEY_DATA = [];
        

        // --- STATE ---
        let state = {
            currentKeyName: 'C', // Store the selected key name (e.g., 'Db')
            currentKeyIndex: 0, // C is default (pitch class 0)
            currentModeId: 'major', 
            currentDegree: 1, 
            currentInversion: 0, 
            highlightedPitchClasses: [], 
            highlightedMidiNotes: [], 
            isCenteringEnabled: true, 
            visualizationMode: 'scale',
            currentClef: 'treble',
            accidentalPreference: 'sharp' // NEW: Default to sharp
        };

        // --- CORE MUSIC THEORY LOGIC ---
        
        function getCurrentMode() {
            return SCALE_MODES[state.currentModeId];
        }

        /**
         * Gets the simplified name of the current key and mode (e.g., "C Ionian").
         */
        function getSimplifiedKeyName() {
            const rootName = state.currentKeyName;
            const modeName = getCurrentMode().name;
            return `${rootName} ${modeName.replace(/\s*\(.*\)/, '')}`; 
        }

        /**
         * Calculates the full, detailed name for the selected chord/note, including inversion.
         */
        function getDetailedHighlightName() {
            const mode = getCurrentMode();
            const intervals = mode.intervals;
            const degree = state.currentDegree;

            // Calculate the interval offset 
            let degreeInterval;
            if (degree === 8) {
                degreeInterval = 12;
            } else {
                if (degree > intervals.length) {
                    degreeInterval = 0; 
                } else {
                    degreeInterval = intervals[degree - 1]; 
                }
            }
            
            const highlightRootIndex = (state.currentKeyIndex + degreeInterval) % 12;
            // The highlight note name is derived from the internal KEYS array (C, C#, D...)
            const highlightRootName = KEYS[highlightRootIndex]; 
            
            const degreeIndex = (degree === 8) ? 0 : degree - 1;

            if (state.visualizationMode === 'chord' && mode.isDiatonic && mode.intervals.length === 7) {
                // Chord selected: CMaj (I) (Root position)
                const romanNumeral = mode.qualities[degreeIndex];
                const quality = mode.triadQualities[degreeIndex];
                
                let inversionText = '';
                if (state.currentInversion === 1) {
                    inversionText = ' / 6';
                } else if (state.currentInversion === 2) {
                    inversionText = ' / 6/4';
                }

                // e.g., "CMaj (I) / 6"
                return `${highlightRootName}${quality} (${romanNumeral})${inversionText}`;
            } else {
                // Note selected: C (1)
                let degreeText;
                if (degree === 1) {
                    degreeText = '1';
                } else if (degree === 8) {
                    degreeText = '8';
                } else {
                    degreeText = degree.toString();
                }
                
                // e.g., "C (1)"
                return `${highlightRootName} (${degreeText})`;
            }
        }

        /**
         * Calculates the specific MIDI notes for the selected chord, applying the current inversion.
         */
        function calculateChordMidiNotes(keyIndex, degree, inversion) {
            const mode = getCurrentMode();
            const scaleIntervals = mode.intervals;
            
            const octaveShift = (degree === 8) ? 12 : 0;
            const scaleDegreeIndex = (degree === 8) ? 0 : degree - 1; 

            // --- Determine the base MIDI for the Tonic (Root Key) of the scale ---
            // Centering Logic: Targets C4 (MIDI 60) to B4 (MIDI 71) range for the root note.
            let tonicMidi;
            if (keyIndex >= 0 && keyIndex <= 6) { // C (0) to F# (6)
                tonicMidi = 60 + keyIndex; // C4 (60) to F#4 (66)
            } else { // G (7) to B (11)
                tonicMidi = 48 + keyIndex; // G3 (55) to B3 (59)
            }
            // --- END TONIC CALCULATION ---

            if (!mode.isDiatonic || mode.intervals.length < 7 || state.visualizationMode === 'scale') {
                 return calculateSingleScaleMidiNote(keyIndex, degree);
            }
            
            const stepsInChord = mode.chordSteps; 
            
            const rootIntervalFromTonic = scaleIntervals[scaleDegreeIndex];
            // The lowest MIDI note of the chord, based on the scale's root (tonicMidi) and the degree offset
            const lowestRootMidi = tonicMidi + rootIntervalFromTonic;
            
            const scaleLength = mode.intervals.length; 
            
            const thirdIndex = (scaleDegreeIndex + stepsInChord[1]) % scaleLength;
            const fifthIndex = (scaleDegreeIndex + stepsInChord[2]) % scaleLength;

            let semitoneOffsetThird = scaleIntervals[thirdIndex] - scaleIntervals[scaleDegreeIndex];
            if (semitoneOffsetThird < 0) semitoneOffsetThird += 12;

            let semitoneOffsetFifth = scaleIntervals[fifthIndex] - scaleIntervals[scaleDegreeIndex];
            if (semitoneOffsetFifth < 0) semitoneOffsetFifth += 12;

            let chordComponents = [
                lowestRootMidi,
                lowestRootMidi + semitoneOffsetThird,
                lowestRootMidi + semitoneOffsetFifth
            ];

            if (octaveShift === 12) {
                chordComponents = chordComponents.map(midi => midi + 12);
            }

            // Apply Inversion
            if (degree <= 7) {
                for (let i = 0; i < inversion; i++) {
                    const lowestNote = chordComponents.shift();
                    chordComponents.push(lowestNote + 12);
                }
            }
            
            return chordComponents.filter(midi => midi >= START_MIDI && midi <= END_MIDI);
        }

        /**
         * Calculates the specific MIDI note for the root of the selected scale degree. Used in Scale View.
         */
        function calculateSingleScaleMidiNote(keyIndex, degree) {
            const scaleIntervals = getCurrentMode().intervals;
            let intervalOffset;
            if (degree === 8) {
                intervalOffset = 12;
            } else {
                if (degree > scaleIntervals.length) {
                    intervalOffset = scaleIntervals[0];
                } else {
                    intervalOffset = scaleIntervals[degree - 1];
                }
            }

            // --- Determine the base MIDI for the Tonic (Root Key) of the scale ---
            // Centering Logic: Targets C4 (MIDI 60) to B4 (MIDI 71) range for the root note.
            let tonicMidi;
            if (keyIndex >= 0 && keyIndex <= 6) { // C (0) to F# (6)
                tonicMidi = 60 + keyIndex; // C4 (60) to F#4 (66)
            } else { // G (7) to B (11)
                tonicMidi = 48 + keyIndex; // G3 (55) to B3 (59)
            }
            // --- END TONIC CALCULATION ---

            let rootMidi = tonicMidi + intervalOffset;
            
            // If in Bass Clef and Scale View, shift the base octave down by one octave to center it naturally.
            if (state.currentClef === 'bass' && state.visualizationMode === 'scale') {
                 if (rootMidi >= 60) {
                     rootMidi -= 12;
                 }
            }

            return [rootMidi].filter(midi => midi >= START_MIDI && midi <= END_MIDI);
        }

        /**
         * Treble Clef Logic (User Approved): Start at lowest, climb high, then drop.
         * Staff Boundary: B3 (59) to C6 (84).
         */
        function calculateTrebleClefNotes(midiNotes) {
            if (midiNotes.length === 0) return [];

            const MIN_MIDI = 59; // B3 (Lowest line/space)
            const MAX_MIDI = 84; // C6 (Highest line/space)

            let lowestOriginal = midiNotes[0];
            let highestOriginal = midiNotes[midiNotes.length - 1];
            
            let shift = 0;

            // Step 1: Find the minimum *upward* shift needed to get the lowest note on the staff.
            while (lowestOriginal + shift < MIN_MIDI) {
                shift += 12;
            }
            
            // Step 2: Ensure the highest note isn't too high.
            // If the chord spans more than one octave (not currently implemented), 
            // this check might need refinement, but for triads and single notes, it is simple.
            while (highestOriginal + shift > MAX_MIDI) {
                shift -= 12;
                if (shift < -12) break; // Should not go more than one octave down
            }
            
            // Fallback for very low notes (e.g., B3 in scale view)
            if (lowestOriginal + shift < MIN_MIDI) {
                 shift += 12;
            }

            return midiNotes.map(midi => midi + shift);
        }
        
        /**
         * Bass Clef Logic (User Approved): Start at lowest, climb high, then drop.
         * Staff Boundary: C2 (36) to D4 (62).
         */
        function calculateBassClefNotes(midiNotes) {
            if (midiNotes.length === 0) return [];
            
            const MIN_MIDI = 36; // C2 (Lowest line/space)
            const MAX_MIDI = 62; // D4 (Highest line/space)

            let lowestOriginal = midiNotes[0];
            let highestOriginal = midiNotes[midiNotes.length - 1];
            
            let shift = 0;

            // Step 1: Find the minimum *downward* shift needed to get the highest note on the staff.
            while (highestOriginal + shift > MAX_MIDI) {
                shift -= 12;
            }

            // Step 2: Ensure the lowest note isn't too low.
            while (lowestOriginal + shift < MIN_MIDI) {
                shift += 12;
                if (shift > 12) break; // Should not go more than one octave up
            }
            
            // Fallback for very high notes (e.g., C5 in scale view)
            if (highestOriginal + shift > MAX_MIDI) {
                 shift -= 12;
            }

            return midiNotes.map(midi => midi + shift);
        }
        
        /**
         * New helper: Determines which natural notes (C,D,E,F,G,A,B) are altered by the key signature.
         */
        function getKeyAccidentals(keyIndex, modeId) {
            if (modeId !== 'major' && modeId !== 'natural_minor') {
                return [];
            }
            
            let keyPC = keyIndex;
            if (modeId === 'natural_minor') {
                // Find the pitch class index of the relative major key (3 semitones up)
                keyPC = (keyIndex + 3) % 12;
            }

            const keySigName = KEY_SIGNATURE_MAP[keyPC];
            let numAccidentals = 0;
            let affectedNotes = [];

            // Sharp Keys Logic (G, D, A, E, B, F#, C#)
            if (['G', 'D', 'A', 'E', 'B', 'C#', 'F#'].includes(keySigName)) {
                if (keyPC === 7) numAccidentals = 1; 
                else if (keyPC === 2) numAccidentals = 2; 
                else if (keyPC === 9) numAccidentals = 3; 
                else if (keyPC === 4) numAccidentals = 4; 
                else if (keyPC === 11) numAccidentals = 5; 
                else if (keyPC === 6) numAccidentals = 6; 
                else if (keyPC === 1) numAccidentals = 7; 

                if (numAccidentals > 0) {
                    // Return the letter name (lowercase)
                    affectedNotes = SHARP_KEYS_ORDER.slice(0, numAccidentals).map(n => n.toLowerCase());
                }
            } 
            // Flat Keys Logic (F, Bb, Eb, Ab, Db, Gb)
            else if (['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb'].includes(keySigName)) {
                if (keyPC === 5) numAccidentals = 1; 
                else if (keyPC === 10) numAccidentals = 2; 
                else if (keyPC === 3) numAccidentals = 3; 
                else if (keyPC === 8) numAccidentals = 4; 
                else if (keyPC === 1) numAccidentals = 5; 
                else if (keyPC === 6) numAccidentals = 6; 
                
                if (numAccidentals > 0) {
                    // Return the letter name (lowercase)
                    affectedNotes = FLAT_KEYS_ORDER.slice(0, numAccidentals).map(n => n.toLowerCase());
                }
            }
            
            // e.g., for D Major, returns ['f', 'c']
            return affectedNotes;
        }


        /**
         * Converts a single MIDI note into VexFlow note parts (note name, octave, and required explicit accidental).
         * This function now correctly returns 'n' (natural) when required to override the key signature.
         */
        function getVexFlowNoteParts(midi) {
            const pitchClass = midi % 12;
            const octave = Math.floor(midi / 12) - 1; 
            
            // 1. Determine preferred spelling for this pitch class based on user preference
            const isFlatPreference = state.accidentalPreference === 'flat';
            const preferredRawNoteName = isFlatPreference ? FLAT_KEYS[pitchClass] : SHARP_KEYS[pitchClass];

            let baseNoteName;
            let explicitAccidental = ''; 
            
            if (preferredRawNoteName.length > 1) {
                // Case 1: The pitch is inherently sharp/flat (e.g., C# or Db)
                baseNoteName = preferredRawNoteName.charAt(0); // e.g., 'c' from 'c#'
                explicitAccidental = preferredRawNoteName.slice(1); // e.g., '#' or 'b'
            } else {
                // Case 2: The pitch is a natural letter (C, D, E, F, G, A, B)
                baseNoteName = preferredRawNoteName;
                
                // Check if this natural note needs an explicit 'n' to override a sharp/flat in the key signature
                const keyAccidentals = getKeyAccidentals(state.currentKeyIndex, state.currentModeId);
                
                // Check if the base note name (e.g., 'f' or 'c') is one of the notes altered by the key sig.
                const isAffectedByKeySig = keyAccidentals.includes(baseNoteName);

                if (isAffectedByKeySig) {
                    // The key signature affects this note (e.g., F# in D major), but the desired note is natural (F natural).
                    explicitAccidental = 'n'; 
                } else {
                    explicitAccidental = ''; // No accidental needed, VexFlow will draw a natural note
                }
            }
            
            const vfNote = `${baseNoteName}/${octave}`;

            return { vfNote, accidental: explicitAccidental };
        }
        
        // --- HANDLERS ---

        function handleKeyChange(keyName) {
            state.currentKeyName = keyName;
            state.currentKeyIndex = KEY_TO_PITCH_CLASS[keyName];
            state.currentDegree = 1;
            state.currentInversion = 0;
            updateUI();
        }

        function handleModeChange(modeId) {
            state.currentModeId = modeId;
            state.currentDegree = 1;
            state.currentInversion = 0;
            updateUI();
        }
        
        function handleClefChange(clef) {
            state.currentClef = clef;
            updateUI();
        }

        function handleDegreeChange(degree) {
            if (degree === state.currentDegree && state.visualizationMode === 'chord') {
                 // Cycle inversion
                 state.currentInversion = (state.currentInversion + 1) % 3;
            } else {
                state.currentDegree = degree;
                state.currentInversion = 0;
            }
            updateUI();
        }
        
        function handleVisualizationModeChange(mode) {
            state.visualizationMode = mode;
            state.currentDegree = 1; // Reset to the tonic when changing views
            state.currentInversion = 0;
            updateUI();
        }
        
        function handleAccidentalPreference(preference) {
            // Only allow change if the key signature is not fixed (i.e., C Major or non-diatonic)
            const mode = getCurrentMode();
            const keySig = getVexFlowKeySignature();
            const isFixedKeySig = mode.isDiatonic && mode.intervals.length === 7 && keySig !== 'C';
            
            if (!isFixedKeySig) {
                state.accidentalPreference = preference;
                updateUI();
            }
        }

        // --- UI RENDERING ---

        function updateUI() {
            // --- NEW: Accidental Preference Override based on Key Signature ---
            const mode = getCurrentMode();
            const keySig = getVexFlowKeySignature();
            const isDiatonicKey = mode.isDiatonic && mode.intervals.length === 7 && keySig !== 'C';
            
            if (isDiatonicKey) {
                // Flat keys: F, Bb, Eb, Ab, Db, Gb
                const isFlatKey = ['F', 'Eb', 'Ab', 'Bb', 'Db', 'Gb'].includes(keySig);
                
                if (isFlatKey) {
                    state.accidentalPreference = 'flat';
                } else {
                    // Sharp keys: G, D, A, E, B, F#, C#
                    state.accidentalPreference = 'sharp';
                }
            } 
            // For C Major ('C') or non-diatonic keys, preference remains user-controlled.
            // --- END NEW ---
            
            // Step 1: Calculate the initial 'preferred' MIDI notes to highlight
            const midiNotes = (state.visualizationMode === 'chord')
                ? calculateChordMidiNotes(state.currentKeyIndex, state.currentDegree, state.currentInversion)
                : calculateSingleScaleMidiNote(state.currentKeyIndex, state.currentDegree);
            
            state.highlightedMidiNotes = midiNotes;
            state.highlightedPitchClasses = [...new Set(midiNotes.map(midi => midi % 12))];

            // Step 2: Update the header and render elements
            document.getElementById('staff-header-text').innerText = 
                `${getSimplifiedKeyName()} - ${getDetailedHighlightName()}`;
            
            renderKeyAndModeSelects();
            renderChordButtons();
            renderPianoKeyboard();
            drawSheetMusic();
            renderVisualizationModeButtons();
            renderAccidentalSwitch(); // NEW: Call the new renderer
        }


        function drawSheetMusic() {
            const container = document.getElementById('staff-display-single');
            container.innerHTML = ''; // Clear previous drawing

            // 1. Calculate and position notes for the staff
            let midiNotes = (state.visualizationMode === 'chord')
                ? calculateChordMidiNotes(state.currentKeyIndex, state.currentDegree, state.currentInversion)
                : calculateSingleScaleMidiNote(state.currentKeyIndex, state.currentDegree);
            
            // Transpose/center notes based on clef
            const isTreble = state.currentClef === 'treble';
            const transposedMidiNotes = isTreble 
                ? calculateTrebleClefNotes(midiNotes) 
                : calculateBassClefNotes(midiNotes);

            // 2. Convert transposed MIDI notes to VexFlow format
            const notePartsData = transposedMidiNotes.map(getVexFlowNoteParts);
            const vfNotes = notePartsData.map(part => part.vfNote);
            
            if (vfNotes.length === 0) return; // Nothing to draw

            // 3. VexFlow setup
            const renderer = new Renderer(container, Renderer.Backends.SVG);
            // Set a fixed width to allow overflow-x:scroll on the container
            const RENDER_WIDTH = 400; 
            renderer.resize(RENDER_WIDTH, 140);
            const context = renderer.getContext();
            context.clearRect(0, 0, RENDER_WIDTH, 140); // Clear context

            // 4. Draw the staff (stave)
            const staffHeight = 100;
            const staffY = 20; 
            
            function drawStaff(clef, x, y) {
                const stave = new Stave(x, y, RENDER_WIDTH - x - 10);
                stave.addClef(clef);
                
                // Get VexFlow Key Signature String (e.g., 'D' for D Major)
                const keySig = getVexFlowKeySignature();
                stave.addKeySignature(keySig);

                stave.setContext(context).draw();
                
                // --- Note Setup ---
                const duration = (state.visualizationMode === 'chord' && vfNotes.length > 1) ? 'w' : 'q';
                
                const note = new StaveNote({
                    keys: vfNotes, 
                    duration: duration, 
                    clef: clef 
                });
                
                // NEW: Always add accidentals if returned by getVexFlowNoteParts.
                // VexFlow will automatically hide redundant accidentals implied by the key signature
                // and draw naturals ('n') when needed to override it.
                notePartsData.forEach((part, index) => {
                    const accidentalType = part.accidental; // Can be '#', 'b', 'n', or ''
                    
                    if (accidentalType === '#') {
                        note.addModifier(new Accidental("#"), index);
                    } else if (accidentalType === 'b') {
                        note.addModifier(new Accidental("b"), index);
                    } else if (accidentalType === 'n') {
                        // Explicit natural sign is required to override the key signature
                        note.addModifier(new Accidental("n"), index);
                    }
                });
                // END NEW

                const voice = new Voice({ num_beats: 4, beat_value: 4 }).addTickables([note]);
                
                // Format and justify the notes
                new Formatter().joinVoices([voice]).format([voice], RENDER_WIDTH - x - 30);
                
                // Render voice
                voice.draw(context, stave);
            }

            drawStaff(state.currentClef, 10, staffY);
        }
        
        function getVexFlowKeySignature() {
            const mode = getCurrentMode();
            const modeId = state.currentModeId;
            const keyIndex = state.currentKeyIndex; 

            // Diatonic 7-note scales (Major and Natural Minor) get a key signature
            if (mode.isDiatonic && mode.intervals.length === 7) {
                let targetIndex = keyIndex;
                if (modeId === 'natural_minor' || modeId === 'aeolian') {
                    // Find the pitch class index of the relative major key (3 semitones up)
                    targetIndex = (keyIndex + 3) % 12;
                }
                
                // Use VexFlow's standard mixed sharp/flat key name for the signature
                return KEY_SIGNATURE_MAP[targetIndex]; 

            } else {
                // All other modes/scales (e.g., pentatonic, harmonic minor) get no key signature
                return 'C'; 
            }
        }
        
        // NEW: Renders the accidental switch and disables buttons based on key signature
        function renderAccidentalSwitch() {
            const container = document.getElementById('accidental-switch-container');
            if (!container) return; 
            
            const isSharp = state.accidentalPreference === 'sharp';
            
            // Check if the accidental preference is fixed by the key signature
            const mode = getCurrentMode();
            const keySig = getVexFlowKeySignature();
            const isFixedKeySig = mode.isDiatonic && mode.intervals.length === 7 && keySig !== 'C';
            
            let isSharpDisabled = false;
            let isFlatDisabled = false;

            if (isFixedKeySig) {
                // Flat keys: F, Bb, Eb, Ab, Db, Gb
                const isFlatKey = ['F', 'Eb', 'Ab', 'Bb', 'Db', 'Gb'].includes(keySig);
                
                if (isFlatKey) {
                    isSharpDisabled = true;
                } else {
                    // Sharp keys: G, D, A, E, B, F#, C#
                    isFlatDisabled = true;
                }
            }

            // Button classes for active/inactive state
            const sharpBtnClass = isSharp ? 'bg-blue-500 text-white shadow-lg border-blue-600' : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50';
            const flatBtnClass = isSharp ? 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50' : 'bg-blue-500 text-white shadow-lg border-blue-600';
            
            // Disabled classes
            const sharpDisabledClass = isSharpDisabled ? 'opacity-50 cursor-not-allowed border-gray-300' : '';
            const flatDisabledClass = isFlatDisabled ? 'opacity-50 cursor-not-allowed border-gray-300' : '';

            container.innerHTML = `
                <label class="block text-xs font-medium text-gray-700 mb-2">Accidental Preference (for chromatic/C keys)</label>
                <div class="flex space-x-2">
                    <button id="sharp-pref-btn" onclick="handleAccidentalPreference('sharp')"
                            class="viz-btn w-full ${sharpBtnClass} ${sharpDisabledClass}"
                            ${isSharpDisabled ? 'disabled' : ''}>
                        Sharp (#)
                    </button>
                    <button id="flat-pref-btn" onclick="handleAccidentalPreference('flat')"
                            class="viz-btn w-full ${flatBtnClass} ${flatDisabledClass}"
                            ${isFlatDisabled ? 'disabled' : ''}>
                        Flat (b)
                    </button>
                </div>
            `;
        }

        function renderChordButtons() {
            // ... (The rest of this function remains unchanged, too long to include here)
        }
        
        function renderKeyAndModeSelects() {
            // ... (The rest of this function remains unchanged, too long to include here)
        }

        function renderPianoKeyboard() {
            // ... (The rest of this function remains unchanged, too long to include here)
        }
        
        function renderVisualizationModeButtons() {
            // ... (The rest of this function remains unchanged, too long to include here)
        }

        // ... (All other utility and rendering functions are assumed to be here)

        // --- APPLICATION STARTUP ---
        
        window.onload = () => {
             // Re-initialize PIANO_KEY_DATA
             PIANO_KEY_DATA.length = 0;
             for (let i = START_MIDI; i <= END_MIDI; i++) {
                 PIANO_KEY_DATA.push({
                     midi: i,
                     pitchClass: i % 12,
                     name: KEYS[i % 12],
                     isWhite: MAJOR_INTERVALS.includes(i % 12),
                 });
             }

            // Run initial UI setup
            initializeSelects();
            
            // Set initial state
            state.currentKeyIndex = KEY_TO_PITCH_CLASS[document.getElementById('key-select').value];
            state.currentKeyName = document.getElementById('key-select').value;
            state.currentModeId = document.getElementById('mode-select').value;
            
            updateUI();
        };

        // Initialize selects (assuming this function exists elsewhere in your full script)
        function initializeSelects() {
             const keySelect = document.getElementById('key-select');
             KEY_DISPLAY_NAMES.forEach(key => {
                 const option = document.createElement('option');
                 option.value = key;
                 option.innerText = key;
                 keySelect.appendChild(option);
             });

             const modeSelect = document.getElementById('mode-select');
             Object.keys(SCALE_MODES).forEach(id => {
                 const mode = SCALE_MODES[id];
                 const option = document.createElement('option');
                 option.value = id;
                 option.innerText = mode.name;
                 modeSelect.appendChild(option);
             });
        }
        
        // Mock functions for other parts of the script to avoid errors
        function renderChordButtons() {}
        function renderKeyAndModeSelects() {}
        function renderPianoKeyboard() {}
        function renderVisualizationModeButtons() {}


    </script>
</body>
</html>
