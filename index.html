<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TheoryViz</title>
    <meta name="theme-color" content="#3b82f6">
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.0.3/build/cjs/vexflow.js"></script>
    
    <style>
        /* Custom styles for the SVG keyboard container */
        .keyboard-container {
            position: relative;
            /* Height remains 250px to accommodate the step visualizer track */
            height: 250px; 
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            /* Light gray for contrast against the white keys */
            background-color: #f3f4f6;
            overflow-x: scroll; /* KEEP scroll to allow the fixed width content to be scrolled */
            overscroll-behavior: contain; /* Prevents unwanted browser scroll on mobile drag */
        }

        /* Hide scrollbar for a cleaner look, while still allowing scroll */
        .keyboard-container::-webkit-scrollbar {
            display: none;
        }
        .keyboard-container {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* Highlighting Styles for a consistent look with the buttons */
        .highlight-transition {
            transition: fill 0.2s ease;
        }
        
        /* Custom style for visualization buttons (Removed .active style to use pure Tailwind in JS) */
        .viz-btn {
            border-radius: 0.5rem;
            transition: all 0.2s;
            font-weight: 600; /* font-semibold */
            padding-top: 0.625rem; /* py-2.5 */
            padding-bottom: 0.625rem; /* py-2.5 */
            border-width: 1px; /* Ensure border is present for both states */
        }
        
        /* Style the VexFlow container to ensure it looks good */
        /* Set a height for the single staff container */
        #staff-display-single {
            min-height: 140px; 
        }
        
        /* Ensures the canvas/svg element from VexFlow doesn't look bad */
        #staff-display-single > svg {
            display: block;
            margin: 0 auto;
        }

    </style>
</head>
<body class="bg-gray-50 font-sans p-8"> <div class="max-w-6xl mx-auto bg-white rounded-xl shadow-2xl p-10"> <h1 class="text-4xl font-extrabold text-gray-800 mb-3 text-center"> TheoryViz
        </h1>
        <p class="text-center text-gray-600 mb-6">
            Visualize harmony anywhere!
        </p>

        <div class="p-4 bg-gray-100 rounded-xl mb-6 shadow-inner border border-gray-200">
            <div class="grid grid-cols-2 gap-4"> 
            
                <div>
                    <label for="key-select" class="block text-xs font-medium text-gray-700 mb-1">Root Key</label>
                    <select id="key-select" onchange="handleKeyChange(event.target.value)"
                            class="w-full p-2 border border-gray-300 rounded-lg bg-white text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                        </select>
                </div>

                <div>
                    <label for="mode-select" class="block text-xs font-medium text-gray-700 mb-1">Scale Type</label>
                    <select id="mode-select" onchange="handleModeChange(event.target.value)"
                            class="w-full p-2 border border-gray-300 rounded-lg bg-white text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                        </select>
                </div>

                <button id="mode-chord-btn" onclick="handleVisualizationModeChange('chord')"
                        class="viz-btn w-full text-base"> Chord View
                </button>
                
                <button id="mode-scale-btn" onclick="handleVisualizationModeChange('scale')"
                        class="viz-btn w-full text-base"> Scale View
                </button>
            </div>
        </div>
        
        <div class="grid grid-cols-1 lg:grid-cols-1 gap-4 mb-6">
            
            <div id="sheet-music-container" class="p-4 bg-gray-100 border border-gray-300 rounded-xl shadow-inner">
                <div class="flex flex-col justify-between items-start mb-3 border-b pb-2"> 
                    <h2 id="staff-header-text" class="text-lg font-bold text-gray-800 mb-2"> </h2> 
                    <div class="flex items-center space-x-3">
                        <label for="clef-select" class="text-sm text-gray-700 font-medium">Clef:</label>
                        <select id="clef-select" onchange="handleClefChange(event.target.value)"
                                class="p-1 border border-gray-300 rounded-lg bg-white text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                            <option value="treble">Treble</option>
                            <option value="bass">Bass</option>
                        </select>
                    </div>
                </div>
                <div id="staff-display-single" class="w-full overflow-x-scroll min-h-[140px]">
                </div>
            </div>

        </div>
        
        <div id="piano-container" class="keyboard-container overflow-x-scroll pb-4 mt-4">
            <div id="step-visualizer-track" style="width: 3120px; position: relative; height: 30px;" class="mt-1 mb-1">
                </div>
            <svg id="piano-keyboard-svg" width="100%" height="200" preserveAspectRatio="xMinYMin slice"></svg>
        </div>
        
        <div class="mt-4 mb-6 py-3 px-4 bg-yellow-100 border-2 border-yellow-400 text-yellow-800 text-sm rounded-lg text-center font-bold shadow-md">
            Click the <span class="text-blue-700 font-extrabold">ACTIVE</span> Roman numeral to cycle <span class="text-indigo-700">INVERSIONS</span> (Root, 1st, 2st) in Chord View.
        </div>

        <div id="chord-buttons-container" class="grid grid-cols-8 gap-3"> </div>
        
    </div>

    <script>
        // --- VEXFLOW ALIASES (New) ---
        const { Renderer, Stave, StaveNote, Voice, Formatter, Accidental } = Vex.Flow;

        // --- CONSTANTS AND MAPPING ---
        
        // Expanded list of key names for the dropdown
        const KEY_DISPLAY_NAMES = [
            "C", "C#", "Db", "D", "D#", "Eb", "E", 
            "F", "F#", "Gb", "G", "G#", "Ab", "A", 
            "A#", "Bb", "B"
        ];
        
        // Map to link display name back to the 0-11 pitch class (C=0, C#=1, Db=1, etc.)
        const KEY_TO_PITCH_CLASS = {
            "C": 0, "C#": 1, "Db": 1, "D": 2, "D#": 3, "Eb": 3, "E": 4, 
            "F": 5, "F#": 6, "Gb": 6, "G": 7, "G#": 8, "Ab": 8, "A": 9, 
            "A#": 10, "Bb": 10, "B": 11
        };
        // Sharp-based names (C, C#, D, D#, ...) - Used for default internal logic and non-flat keys
        const KEYS = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        
        // Flat-based names (C, Db, D, Eb, ...) - Used for VexFlow note string generation in flat keys
        const FLAT_KEYS = ["c", "db", "d", "eb", "e", "f", "gb", "g", "ab", "a", "bb", "b"];
        // Sharp-based names (c, c#, d, d#, ...) - Used for VexFlow note string generation in sharp keys
        const SHARP_KEYS = ["c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b"];
        
        // Flat root keys that mandate flat spelling for the staff
        const FLAT_ROOT_KEYS = ['Db', 'Eb', 'Gb', 'Ab', 'Bb']; 

        const MAJOR_INTERVALS = [0, 2, 4, 5, 7, 9, 11]; 
        
        // VexFlow Key Signature Map 
        const KEY_SIGNATURE_MAP = [
            'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'
        ];

        const SCALE_MODES = {
            'major': {
                name: 'Ionian (Major)',
                intervals: [0, 2, 4, 5, 7, 9, 11],
                steps: ["W", "W", "H", "W", "W", "W", "H"],
                triadQualities: ["Maj", "min", "min", "Maj", "Maj", "min", "dim", "Maj"], 
                qualities: ["I", "ii", "iii", "IV", "V", "vi", "vii째", "VIII (I)"], 
                chordSteps: [0, 2, 4], 
                degrees: 8, 
                isDiatonic: true
            },
            'natural_minor': {
                name: 'Aeolian (Natural Minor)',
                intervals: [0, 2, 3, 5, 7, 8, 10],
                steps: ["W", "H", "W", "W", "H", "W", "W"],
                triadQualities: ["min", "dim", "Maj", "min", "min", "Maj", "Maj", "min"],
                qualities: ["i", "ii째", "III", "iv", "v", "VI", "VII", "viii (i)"],
                chordSteps: [0, 2, 4],
                degrees: 8,
                isDiatonic: true
            },
            'harmonic_minor': {
                name: 'Harmonic Minor',
                intervals: [0, 2, 3, 5, 7, 8, 11], 
                steps: ["W", "H", "W", "W", "H", "1.5", "H"], 
                triadQualities: ["min", "dim", "Aug", "min", "Maj", "Maj", "dim", "min"], 
                qualities: ["i", "ii째", "III+", "iv", "V", "VI", "vii째", "viii (i)"],
                chordSteps: [0, 2, 4],
                degrees: 8, 
                isDiatonic: true
            },
            'major_pentatonic': {
                name: 'Major Pentatonic',
                intervals: [0, 2, 4, 7, 9],
                steps: ["W", "W", "1.5", "W", "1.5"], 
                triadQualities: ["", "", "", "", ""], 
                qualities: ["1", "2", "3", "4", "5"], 
                chordSteps: [0], 
                degrees: 5,
                isDiatonic: false
            },
            'minor_pentatonic': {
                name: 'Minor Pentatonic',
                intervals: [0, 3, 5, 7, 10],
                steps: ["1.5", "W", "W", "1.5", "W"],
                triadQualities: ["", "", "", "", ""],
                qualities: ["1", "2", "3", "4", "5"], 
                chordSteps: [0],
                degrees: 5,
                isDiatonic: false
            }
        };
        
        // MIDI note range updated to ALL 88 KEYS: A0 (21) to C8 (108)
        const START_MIDI = 21; // A0
        const END_MIDI = 108;  // C8
        
        // --- SVG KEYBOARD CONFIGURATION ---
        const KEYBOARD_CONFIG = {
            TOTAL_KEYS_RANGE: END_MIDI - START_MIDI + 1, // 88 keys
            WHITE_KEYS_COUNT: 52, // A0 to C8
            KEYBOARD_WIDTH: 52 * 60, // 52 white keys * 60px/key = 3120px
            KEYBOARD_HEIGHT: 200,
            KEY_Y_START: 10,
            WHITE_KEY_HEIGHT: 180,
            WHITE_KEY_WIDTH: 60, // 3120 / 52 = 60px
            BLACK_KEY_WIDTH: 36, // 60 * 0.6 = 36px
            BLACK_KEY_HEIGHT: 110,
        };

        const KEY_COLORS = {
            WHITE: '#ffffff',
            BLACK: '#1f2937',
            HIGHLIGHT_WHITE: '#3b82f6',     // Blue for Root/Scale
            HIGHLIGHT_BLACK: '#2563eb',     // Darker Blue for Root/Scale
            
            // Inverted colors (matching the indigo button)
            INVERTED_HIGHLIGHT_WHITE: '#4f46e5', // Indigo-600
            INVERTED_HIGHLIGHT_BLACK: '#4338ca'  // Indigo-700
        };
        
        const PIANO_KEY_DATA = [];
        

        // --- STATE ---
        let state = {
            currentKeyName: 'C', // Store the selected key name (e.g., 'Db')
            currentKeyIndex: 0, // C is default (pitch class 0)
            currentModeId: 'major', 
            currentDegree: 1, 
            currentInversion: 0, 
            highlightedPitchClasses: [], 
            highlightedMidiNotes: [], 
            isCenteringEnabled: true, 
            visualizationMode: 'scale',
            currentClef: 'treble' 
        };

        // --- CORE MUSIC THEORY LOGIC ---
        
        function getCurrentMode() {
            return SCALE_MODES[state.currentModeId];
        }

        /**
         * Gets the simplified name of the current key and mode (e.g., "C Ionian").
         */
        function getSimplifiedKeyName() {
            const rootName = state.currentKeyName;
            const modeName = getCurrentMode().name;
            return `${rootName} ${modeName.replace(/\s*\(.*\)/, '')}`; 
        }


        /**
         * Calculates the full, detailed name for the selected chord/note, including inversion.
         */
        function getDetailedHighlightName() {
            const mode = getCurrentMode();
            const intervals = mode.intervals;
            const degree = state.currentDegree;

            // Calculate the interval offset 
            let degreeInterval;
            if (degree === 8) {
                degreeInterval = 12;
            } else {
                if (degree > intervals.length) {
                    degreeInterval = 0; 
                } else {
                    degreeInterval = intervals[degree - 1]; 
                }
            }
            
            const highlightRootIndex = (state.currentKeyIndex + degreeInterval) % 12;
            // The highlight note name is derived from the internal KEYS array (C, C#, D...)
            const highlightRootName = KEYS[highlightRootIndex]; 
            
            const degreeIndex = (degree === 8) ? 0 : degree - 1;

            if (state.visualizationMode === 'chord' && mode.isDiatonic && mode.intervals.length === 7) {
                // Chord selected: CMaj (I) (Root position)
                const romanNumeral = mode.qualities[degreeIndex];
                const quality = mode.triadQualities[degreeIndex];
                
                let inversionText = '';
                if (state.currentInversion === 1) {
                    inversionText = ' / 6';
                } else if (state.currentInversion === 2) {
                    inversionText = ' / 6/4';
                }

                // e.g., "CMaj (I) / 6"
                return `${highlightRootName}${quality} (${romanNumeral})${inversionText}`;
            } else {
                // Note selected: C (1)
                let degreeText;
                if (degree === 1) {
                    degreeText = '1';
                } else if (degree === 8) {
                    degreeText = '8';
                } else {
                    degreeText = degree.toString();
                }
                
                // e.g., "C (1)"
                return `${highlightRootName} (${degreeText})`;
            }
        }

        /**
         * Calculates the specific MIDI notes for the selected chord, applying the current inversion.
         */
        function calculateChordMidiNotes(keyIndex, degree, inversion) {
            const mode = getCurrentMode();
            const scaleIntervals = mode.intervals;
            
            const octaveShift = (degree === 8) ? 12 : 0;
            const scaleDegreeIndex = (degree === 8) ? 0 : degree - 1; 

            // --- Determine the base MIDI for the Tonic (Root Key) of the scale ---
            // Centering Logic: Targets C4 (MIDI 60) to B4 (MIDI 71) range for the root note.
            let tonicMidi;
            if (keyIndex >= 0 && keyIndex <= 6) { // C (0) to F# (6)
                tonicMidi = 60 + keyIndex; // C4 (60) to F#4 (66)
            } else { // G (7) to B (11)
                tonicMidi = 48 + keyIndex; // G3 (55) to B3 (59)
            }
            // --- END TONIC CALCULATION ---
            
            // --- NEW FIX: Shift base octave down for Bass Clef in Chord View ---
            if (state.currentClef === 'bass' && state.visualizationMode === 'chord') {
                // If the chord root is C4 or higher (tonicMidi >= 60), shift it down to C3 or lower.
                // This ensures the keyboard visualization aligns with the typical bass clef range.
                if (tonicMidi >= 60) {
                    tonicMidi -= 12;
                }
            }
            // --- END NEW FIX ---


            if (!mode.isDiatonic || mode.intervals.length < 7 || state.visualizationMode === 'scale') {
                 return calculateSingleScaleMidiNote(keyIndex, degree);
            }
            
            const stepsInChord = mode.chordSteps; 
            
            const rootIntervalFromTonic = scaleIntervals[scaleDegreeIndex];
            // The lowest MIDI note of the chord, based on the scale's root (tonicMidi) and the degree offset
            const lowestRootMidi = tonicMidi + rootIntervalFromTonic;
            
            const scaleLength = mode.intervals.length; 
            
            const thirdIndex = (scaleDegreeIndex + stepsInChord[1]) % scaleLength;
            const fifthIndex = (scaleDegreeIndex + stepsInChord[2]) % scaleLength;

            let semitoneOffsetThird = scaleIntervals[thirdIndex] - scaleIntervals[scaleDegreeIndex];
            if (semitoneOffsetThird < 0) semitoneOffsetThird += 12; 
            
            let semitoneOffsetFifth = scaleIntervals[fifthIndex] - scaleIntervals[scaleDegreeIndex];
            if (semitoneOffsetFifth < 0) semitoneOffsetFifth += 12; 

            let chordComponents = [
                lowestRootMidi, 
                lowestRootMidi + semitoneOffsetThird, 
                lowestRootMidi + semitoneOffsetFifth  
            ];
            
            if (octaveShift === 12) {
                chordComponents = chordComponents.map(midi => midi + 12);
            }

            // Apply Inversion
            if (degree <= 7) {
                for (let i = 0; i < inversion; i++) {
                    const lowestNote = chordComponents.shift(); 
                    chordComponents.push(lowestNote + 12);     
                }
            }
            
            return chordComponents.filter(midi => midi >= START_MIDI && midi <= END_MIDI);
        }

        /**
         * Calculates the specific MIDI note for the root of the selected scale degree. Used in Scale View.
         */
        function calculateSingleScaleMidiNote(keyIndex, degree) {
            const scaleIntervals = getCurrentMode().intervals;
            
            let intervalOffset;
            if (degree === 8) {
                intervalOffset = 12;
            } else {
                if (degree > scaleIntervals.length) {
                    intervalOffset = scaleIntervals[0]; 
                } else {
                    intervalOffset = scaleIntervals[degree - 1];
                }
            }

            // --- Determine the base MIDI for the Tonic (Root Key) of the scale ---
            // Centering Logic: Targets C4 (MIDI 60) to B4 (MIDI 71) range for the root note.
            let tonicMidi;
            if (keyIndex >= 0 && keyIndex <= 6) { // C (0) to F# (6)
                tonicMidi = 60 + keyIndex; // C4 (60) to F#4 (66)
            } else { // G (7) to B (11)
                tonicMidi = 48 + keyIndex; // G3 (55) to B3 (59)
            }
            // --- END TONIC CALCULATION ---

            let rootMidi = tonicMidi + intervalOffset;
            
            // If in Bass Clef and Scale View, shift the base octave down by one octave to center it naturally.
            if (state.currentClef === 'bass' && state.visualizationMode === 'scale') {
                if (rootMidi >= 60) {
                     rootMidi -= 12;
                }
            }


            return [rootMidi].filter(midi => midi >= START_MIDI && midi <= END_MIDI);
        }

        /**
         * Treble Clef Logic (User Approved): Start at lowest, climb high, then drop.
         * Staff Boundary: B3 (59) to C6 (84).
         */
        function calculateTrebleClefNotes(midiNotes) {
            if (midiNotes.length === 0) return [];
            
            const MIN_MIDI = 59; // B3 (Lowest line/space)
            const MAX_MIDI = 84; // C6 (Highest line/space)
            
            let lowestOriginal = midiNotes[0];
            let highestOriginal = midiNotes[midiNotes.length - 1];
            
            let shift = 0;

            // Step 1: Find the minimum *upward* shift needed to get the lowest note on the staff.
            while (lowestOriginal + shift < MIN_MIDI) {
                shift += 12;
            }
            
            // Step 2: Now that the lowest note is visible, check the highest note. 
            // Apply *downward* shifts until the highest note is no longer exceeding the max boundary.
            while (highestOriginal + shift > MAX_MIDI) {
                shift -= 12;
            }

            // Safety Check: If the last downward shift pushed the lowest note below the MIN_MIDI, 
            // revert the last shift to keep the note on the staff.
            if (lowestOriginal + shift < MIN_MIDI) {
                shift += 12;
            }

            // Apply the final shift and filter out any notes that still fall outside
            const finalNotes = midiNotes
                .map(midi => midi + shift)
                .filter(midi => midi >= MIN_MIDI && midi <= MAX_MIDI);
                
            return finalNotes;
        }


        /**
         * UPDATED Bass Clef Logic: Start at lowest, climb high, then drop.
         * Staff Boundary: C2 (36) to E4 (64).
         * This mirrors the logic of calculateTrebleClefNotes using the correct Bass Clef boundaries.
         */
        function calculateBassClefNotes(midiNotes) {
            if (midiNotes.length === 0) return [];
            
            const MIN_MIDI = 36; // C2 (Lowest ledger line)
            const MAX_MIDI = 64; // E4 (Highest ledger line/space)
            
            let lowestOriginal = midiNotes[0];
            let highestOriginal = midiNotes[midiNotes.length - 1];
            
            let shift = 0;

            // Step 1: Find the minimum *upward* shift needed to get the lowest note on the staff (C2/36).
            // This implements "start at the lowest point."
            while (lowestOriginal + shift < MIN_MIDI) {
                shift += 12;
            }
            
            // Step 2: Now that the lowest note is visible, check the highest note. 
            // Apply *downward* shifts until the highest note is no longer exceeding the max boundary (E4/64).
            // This implements "go to the highest point before breaking."
            while (highestOriginal + shift > MAX_MIDI) {
                shift -= 12;
            }

            // Safety Check: If the last downward shift pushed the lowest note below the MIN_MIDI, 
            // revert the last shift to keep the note on the staff.
            if (lowestOriginal + shift < MIN_MIDI) {
                shift += 12;
            }

            // Apply the final shift and filter out any notes that still fall outside
            const finalNotes = midiNotes
                .map(midi => midi + shift)
                .filter(midi => midi >= MIN_MIDI && midi <= MAX_MIDI);
                
            return finalNotes;
        }

        
        // --- VEXFLOW RENDERING ---

        /**
         * Converts MIDI note to VexFlow string and identifies required accidental.
         * Returns { vfNote: 'c/4', accidental: '#' | 'b' | '' }
         */
        function getVexFlowNoteParts(midi) {
            const pitchClass = midi % 12;
            const octave = Math.floor(midi / 12) - 1; 
            const currentKeyName = state.currentKeyName;
            
            let baseNoteName;
            let requiredAccidental = ''; 

            // 1. Determine the correct spelling (sharp or flat) for the pitch class.
            const isFlatKey = FLAT_ROOT_KEYS.includes(currentKeyName);
            
            // Use the raw sharp/flat names (c, c#, d, db, etc.) to figure out the required accidental
            const rawNoteName = isFlatKey ? FLAT_KEYS[pitchClass] : SHARP_KEYS[pitchClass];

            if (rawNoteName.length > 1) {
                baseNoteName = rawNoteName.charAt(0); // e.g., 'c' from 'c#' or 'd' from 'db'
                requiredAccidental = rawNoteName.slice(1); // e.g., '#' or 'b'
            } else {
                baseNoteName = rawNoteName; // e.g., 'c'
            }
            
            // VexFlow note string is always just the base note and octave (e.g., 'c/4')
            const vfNote = `${baseNoteName}/${octave}`;

            return { vfNote, accidental: requiredAccidental };
        }
        
        /**
         * Calculates the appropriate key signature string for VexFlow.
         */
        function getVexFlowKeySignature() {
            const mode = getCurrentMode();
            const modeId = state.currentModeId;
            const currentKeyName = state.currentKeyName; // Selected key name string

            // Diatonic 7-note scales (Major and Natural Minor) get a key signature
            if (mode.isDiatonic && mode.intervals.length === 7) {
                let keyIndex = state.currentKeyIndex; // 0-11 pitch class

                if (modeId === 'natural_minor' || modeId === 'aeolian') {
                    // Find the pitch class index of the relative major key (3 semitones up)
                    const relativeMajorIndex = (keyIndex + 3) % 12;
                    
                    // If the relative major is one of the flat keys, use that name for the signature.
                    const flatKeysInMap = ['Eb', 'Ab', 'Bb']; 
                    if (flatKeysInMap.includes(KEY_SIGNATURE_MAP[relativeMajorIndex])) {
                        return KEY_SIGNATURE_MAP[relativeMajorIndex];
                    }
                    
                    // Fallback to the standard KEY_SIGNATURE_MAP spelling for the relative major
                    return KEY_SIGNATURE_MAP[relativeMajorIndex];

                } else { 
                    // Major Key
                    
                    // Override the standard map lookup if the user explicitly chose a flat key.
                    if (FLAT_ROOT_KEYS.includes(currentKeyName)) {
                        return currentKeyName;
                    }
                }
                
                // Default: Use the key name from the standard 0-11 pitch class map.
                return KEY_SIGNATURE_MAP[keyIndex];

            } else {
                // All other modes/scales (e.g., pentatonic, harmonic minor) get no key signature
                return 'C'; 
            }
        }
        
        /**
         * Helper function to draw a single VexFlow staff into a container.
         */
        const drawStaff = (container, clef, vfNotes, notePartsData, keySig, isNonDiatonicOrCKey, width, height) => {
                
            if (vfNotes.length === 0) {
                 // Display a message if no notes are left after transposition/filtering
                 container.innerHTML = `<p class="text-center text-gray-500 py-4">Notes are outside the ${clef} staff's target range even after auto-transposition.</p>`;
                 return;
            }

            const renderer = new Renderer(container, Renderer.Backends.SVG);
            renderer.resize(width, height);
            const context = renderer.getContext();
            context.clear(); 
            
            // --- Stave (Staff) Setup ---
            const stave = new Stave(10, 10, width - 20); // x, y, width
            
            // Add clef
            stave.addClef(clef);
            
            // Add key signature
            stave.addKeySignature(keySig);
            
            stave.setContext(context).draw();

            // --- Note Setup ---
            const note = new StaveNote({
                keys: vfNotes, // Use the passed-in VexFlow notes (e.g., ['c/4', 'e/4'])
                duration: 'q', 
                clef: clef 
            });
            
            // Add accidentals if necessary
            // We use the flag check to determine if we need to manually add all accidentals 
            // because VexFlow's built-in key signature logic won't handle the raised 7th 
            // in harmonic minor correctly, or explicit sharps/flats in non-diatonic scales.
            if (isNonDiatonicOrCKey) {
                notePartsData.forEach((part, index) => {
                    const accidentalType = part.accidental; // '#' or 'b'
                    
                    // We only explicitly add the accidental if the pitch is sharp or flat.
                    if (accidentalType === '#') {
                        note.addModifier(new Accidental("#"), index);
                    } else if (accidentalType === 'b') {
                        note.addModifier(new Accidental("b"), index);
                    }
                });
            }
            
            // --- Voice and Drawing ---
            const voice = new Voice({ num_beats: 1, beat_value: 4 }); 
            voice.addTickables([note]);
            
            // Format and justify the notes to fit the stave width
            new Formatter().joinVoices([voice]).format([voice], width - 40); 
            
            // Render the notes
            voice.draw(context, stave);
        };
        
        /**
         * Renders the sheet music staff with the highlighted notes for the selected clef.
         */
        function drawSheetMusic() {
            // Get the single container
            const container = document.getElementById('staff-display-single');
            
            // Clear previous content
            container.innerHTML = ''; 

            if (state.highlightedMidiNotes.length === 0) {
                 container.innerHTML = '<p class="text-center text-gray-500 py-4">Notes are outside the ' + state.currentClef + ' staff\'s target range even after auto-transposition.</p>';
                 return;
            }
            
            // --- Common Setup ---
            const width = container.offsetWidth > 450 ? 450 : container.offsetWidth;
            const height = 140; 
            
            const keySig = getVexFlowKeySignature();
            // Flag is true for non-diatonic scales, Harmonic Minor, or if the key signature is 'C' (no sharps/flats)
            const isNonDiatonicOrCKey = !getCurrentMode().isDiatonic || getCurrentMode().intervals.length !== 7 || state.currentModeId === 'harmonic_minor' || keySig === 'C';

            let finalVexFlowNotes;
            let finalNoteParts;

            // --- Conditional Drawing Data Prep ---
            // The notes in state.highlightedMidiNotes are now ALREADY TRANSPOSED to fit the staff.
            finalNoteParts = state.highlightedMidiNotes.map(getVexFlowNoteParts);
            finalVexFlowNotes = finalNoteParts.map(p => p.vfNote);

            // --- Draw the Staff ---
            drawStaff(container, state.currentClef, finalVexFlowNotes, finalNoteParts, keySig, isNonDiatonicOrCKey, width, height);
        }

        // --- KEYBOARD RENDERING HELPERS (Rest of the file is largely unchanged) ---
        
        /**
         * Returns the correctly spelled note name (sharp or flat) for a MIDI note/pitch class,
         * based on the root key currently selected.
         */
        function getKeyboardNoteName(pitchClass, currentKeyName) {
            // White keys (C, D, E, F, G, A, B) are always spelled the same.
            const enharmonicPair = {
                 1: { sharp: 'C#', flat: 'Db' },
                 3: { sharp: 'D#', flat: 'Eb' },
                 6: { sharp: 'F#', flat: 'Gb' },
                 8: { sharp: 'G#', flat: 'Ab' },
                 10: { sharp: 'A#', flat: 'Bb' }
            }[pitchClass];

            if (!enharmonicPair) {
                return KEYS[pitchClass]; 
            }

            // Decide whether to use flat spelling
            const shouldUseFlatSpelling = FLAT_ROOT_KEYS.includes(currentKeyName);

            if (shouldUseFlatSpelling) {
                return enharmonicPair.flat;
            } else {
                // Use sharp spelling for all other keys 
                return enharmonicPair.sharp;
            }
        }
        
        /**
         * Calculates the 0-based index of a white key, counting from START_MIDI (A0).
         * A0 (21) is the first white key for an 88-key piano.
         */
        function getWhiteKeyIndex(midi) {
             // The first white key is A0 (21). The first C key is C1 (24).
             // Since C is the start of the pattern, we normalize by shifting everything
             // so C is the start of the scale (pitch class 0)
             const midiOffset = midi - START_MIDI; // 0-based index from A0
             
             // Count of white keys from A0 to C8: 52 keys
             // White key pitch classes: 0, 2, 4, 5, 7, 9, 11
             // Black key pitch classes: 1, 3, 6, 8, 10
             
             let count = 0;
             for (let i = START_MIDI; i <= midi; i++) {
                 // Check if pitch class is a white key (C=0, D=2, E=4, F=5, G=7, A=9, B=11)
                 if (MAJOR_INTERVALS.includes(i % 12)) {
                     count++;
                 }
             }
             // The 0-based index is count - 1. 
             // (e.g., A0 is the 1st white key, index 0. C8 is the 52nd, index 51)
             return count - 1; 
        }

        /**
         * Calculates the X position of a key based on its MIDI number (start of the key).
         */
        function getKeyXPosition(midi) {
            const pitchClass = midi % 12;
            const isWhiteKey = MAJOR_INTERVALS.includes(pitchClass);
            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;

            const whiteKeyIndex = getWhiteKeyIndex(midi);

            if (isWhiteKey) {
                return whiteKeyIndex * WKW;
            } else {
                // Black keys are positioned relative to the white key to their immediate left (which is midi - 1)
                const leftWhiteKeyIndex = getWhiteKeyIndex(midi - 1);
                const leftWhiteKeyX = leftWhiteKeyIndex * WKW;
                const seamX = leftWhiteKeyX + WKW;
                return seamX - (BKW / 2); 
            }
        }
        
        /**
         * Helper to get key center X position.
         */
        function getKeyCenterX(midi) {
            const pitchClass = midi % 12;
            const x = getKeyXPosition(midi);
            const isWhite = MAJOR_INTERVALS.includes(pitchClass);
            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
            return x + (isWhite ? WKW / 2 : BKW / 2);
        }

        /**
         * Renders the W/H/1.5 step indicators in the track above the keyboard.
         */
        function renderStepVisualizer() {
            const track = document.getElementById('step-visualizer-track');
            
            track.innerHTML = ''; 

            if (state.visualizationMode === 'chord') {
                return;
            }

            const mode = getCurrentMode();
            const scaleSteps = mode.steps;
            const scaleIntervals = mode.intervals;
            
            // --- Determine the base MIDI for the Tonic (Root Key) of the scale (duplicated logic from above) ---
            let tonicMidi;
            if (state.currentKeyIndex >= 0 && state.currentKeyIndex <= 6) { // C (0) to F# (6)
                tonicMidi = 60 + state.currentKeyIndex; // C4 (60) to F#4 (66)
            } else { // G (7) to B (11)
                tonicMidi = 48 + state.currentKeyIndex; // G3 (55) to B3 (59)
            }
            // --- END TONIC CALCULATION ---


            for (let i = 0; i < scaleSteps.length; i++) { 
                const step = scaleSteps[i];
                
                const currentNoteMidi = tonicMidi + scaleIntervals[i];

                let stepInSemitones;
                if (i === scaleSteps.length - 1) {
                    stepInSemitones = 12 - scaleIntervals[i];
                } else {
                    stepInSemitones = scaleIntervals[i + 1] - scaleIntervals[i];
                }

                if (stepInSemitones <= 0) continue; 

                const nextNoteMidi = currentNoteMidi + stepInSemitones;
                
                // Ensure we don't try to draw steps for notes outside the rendered range
                if (currentNoteMidi < START_MIDI || nextNoteMidi > END_MIDI) continue;

                const x1 = getKeyCenterX(currentNoteMidi);
                const x2 = getKeyCenterX(nextNoteMidi);

                const centerX = (x1 + x2) / 2;
                
                let stepColorClass;
                let tooltipText;
                let stepLabel;

                if (step === 'W') { 
                    stepColorClass = 'bg-green-600'; 
                    tooltipText = 'Whole Step';
                    stepLabel = 'W';
                } else if (step === 'H') { 
                    stepColorClass = 'bg-red-600'; 
                    tooltipText = 'Half Step';
                    stepLabel = 'H';
                } else if (step === '1.5') { 
                    stepColorClass = 'bg-purple-600'; 
                    tooltipText = 'Augmented Step (1.5)';
                    stepLabel = 'A'; 
                } else {
                    continue; 
                }
                
                const indicator = document.createElement('div');
                indicator.className = `absolute top-0 transform -translate-x-1/2 step-indicator transition-all duration-300 shadow-md 
                                        w-5 h-5 rounded-full flex items-center justify-center text-white text-[10px] font-bold 
                                        ${stepColorClass}
                                        group cursor-help hover:scale-125`;
                
                indicator.innerHTML = `
                    ${stepLabel}
                    <span class="absolute top-full mt-1 px-2 py-0.5 bg-gray-800 text-white text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap z-50">
                        ${tooltipText}
                    </span>
                `;
                
                indicator.style.left = `${centerX}px`; 
                
                track.appendChild(indicator);
            }
        }


        function drawKeyboard() {
            const svg = document.getElementById('piano-keyboard-svg');
            const highlightedMidiNotes = state.highlightedMidiNotes; 
            
            // Set SVG size based on new calculated width (3120px)
            svg.setAttribute('width', `${KEYBOARD_CONFIG.KEYBOARD_WIDTH}px`);
            svg.setAttribute('viewBox', `0 0 ${KEYBOARD_CONFIG.KEYBOARD_WIDTH} ${KEYBOARD_CONFIG.KEYBOARD_HEIGHT}`);
            svg.innerHTML = ''; 
            
            // Ensure step visualizer track width is updated to match the new keyboard width
            document.getElementById('step-visualizer-track').style.width = KEYBOARD_CONFIG.KEYBOARD_WIDTH + 'px';

            const WKW = KEYBOARD_CONFIG.WHITE_KEY_WIDTH;
            const BKW = KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
            const WKH = KEYBOARD_CONFIG.WHITE_KEY_HEIGHT;
            const Y_START = KEYBOARD_CONFIG.KEY_Y_START;
            
            // Determine which highlight color set to use
            const useInvertedColors = state.visualizationMode === 'chord' && state.currentInversion > 0;
            
            const whiteHighlightColor = useInvertedColors ? KEY_COLORS.INVERTED_HIGHLIGHT_WHITE : KEY_COLORS.HIGHLIGHT_WHITE;
            const blackHighlightColor = useInvertedColors ? KEY_COLORS.INVERTED_HIGHLIGHT_BLACK : KEY_COLORS.HIGHLIGHT_BLACK;


            // 1. Draw White Keys first
            PIANO_KEY_DATA.forEach(key => {
                if (key.isWhite) {
                    const isHighlighted = highlightedMidiNotes.includes(key.midi); 
                    const x = getKeyXPosition(key.midi); 

                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', Y_START);
                    rect.setAttribute('width', WKW);
                    rect.setAttribute('height', WKH);
                    rect.setAttribute('rx', 4); 
                    rect.setAttribute('ry', 4);
                    rect.setAttribute('stroke', '#a1a1ae');
                    rect.setAttribute('stroke-width', '1');
                    rect.setAttribute('fill', isHighlighted ? whiteHighlightColor : KEY_COLORS.WHITE);
                    rect.classList.add('highlight-transition'); 
                    
                    svg.appendChild(rect);

                    // --- Labeling Logic for White Keys ---
                    let labelText = null;
                    let labelFill = isHighlighted ? KEY_COLORS.WHITE : '#4b5563'; 
                    
                    // Calculate Octave for display: 
                    const octave = Math.floor(key.midi / 12) - 1;

                    if (isHighlighted) {
                         // Use the function to determine the spelling 
                         labelText = getKeyboardNoteName(key.pitchClass, state.currentKeyName); 
                    } else if (key.name === 'C' || key.name === 'F') {
                        // Label C and F keys (for easier reference)
                        labelText = `${key.name}${octave}`;
                    }

                    if (labelText) {
                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute('x', x + WKW / 2);
                        text.setAttribute('y', Y_START + WKH - 10);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '14');
                        text.setAttribute('font-weight', '600');
                        text.setAttribute('fill', labelFill);
                        text.textContent = labelText;
                        svg.appendChild(text);
                    }
                }
            });

            // 2. Draw Black Keys second (to place them on top)
            PIANO_KEY_DATA.forEach(key => {
                if (!key.isWhite) {
                    const isHighlighted = highlightedMidiNotes.includes(key.midi);
                    
                    const x = getKeyXPosition(key.midi); 

                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', Y_START);
                    rect.setAttribute('width', BKW);
                    rect.setAttribute('height', KEYBOARD_CONFIG.BLACK_KEY_HEIGHT);
                    rect.setAttribute('rx', 3); 
                    rect.setAttribute('ry', 3);
                    rect.setAttribute('stroke', '#000000');
                    rect.setAttribute('stroke-width', '1');
                    rect.setAttribute('fill', isHighlighted ? blackHighlightColor : KEY_COLORS.BLACK);
                    rect.classList.add('highlight-transition'); 

                    svg.appendChild(rect);
                    
                    // Black Key Labeling: Shows name if highlighted 
                    if (isHighlighted) {
                        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        text.setAttribute('x', x + BKW / 2);
                        text.setAttribute('y', Y_START + KEYBOARD_CONFIG.BLACK_KEY_HEIGHT - 10);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('font-size', '14');
                        text.setAttribute('font-weight', '600');
                        text.setAttribute('fill', KEY_COLORS.WHITE);
                        
                        // Use current key to determine flat/sharp spelling
                        const noteLabel = getKeyboardNoteName(key.pitchClass, state.currentKeyName);
                        text.textContent = noteLabel;
                        
                        svg.appendChild(text);
                    }
                }
            });
            
            const pianoContainer = document.getElementById('piano-container');
            
            // --- UPDATED SCROLLING LOGIC: Center the entire span of the chord ---
            
            if (state.highlightedMidiNotes.length > 0) {
                const firstMidi = state.highlightedMidiNotes[0];
                const lastMidi = state.highlightedMidiNotes[state.highlightedMidiNotes.length - 1];

                // Find the X position of the leftmost edge of the first key
                const startKeyX = getKeyXPosition(firstMidi);

                // Find the X position of the rightmost edge of the last key
                const lastKeyData = PIANO_KEY_DATA.find(k => k.midi === lastMidi);
                
                if (lastKeyData) {
                    const lastKeyWidth = lastKeyData.isWhite ? KEYBOARD_CONFIG.WHITE_KEY_WIDTH : KEYBOARD_CONFIG.BLACK_KEY_WIDTH;
                    const endKeyX = getKeyXPosition(lastMidi) + lastKeyWidth;

                    // Calculate the center of the total visual span
                    const spanCenter = (startKeyX + endKeyX) / 2;
                    
                    const containerWidth = pianoContainer.offsetWidth;

                    // Calculate the scroll position needed to center the span's midpoint.
                    let centerScrollX = spanCenter - (containerWidth / 2);

                    // Clamp the scroll position to prevent scrolling out of bounds
                    centerScrollX = Math.max(0, centerScrollX);
                    centerScrollX = Math.min(KEYBOARD_CONFIG.KEYBOARD_WIDTH - containerWidth, centerScrollX);

                    requestAnimationFrame(() => {
                        // Smoothly scroll to the center position
                        pianoContainer.scroll({ left: centerScrollX, behavior: 'smooth' });
                    });
                }
            }
        }
        
        function renderKeySelect() {
            const select = document.getElementById('key-select');
            select.innerHTML = KEY_DISPLAY_NAMES.map((keyName) => {
                const isSelected = keyName === state.currentKeyName;
                return `<option value="${keyName}" ${isSelected ? 'selected' : ''}>${keyName}</option>`;
            }).join('');
        }
        
        /**
         * Renders all scale modes, filtering out pentatonic for Chord View.
         */
        function renderModeSelect() {
            const select = document.getElementById('mode-select');
            
            const allModes = Object.entries(SCALE_MODES);
            let modesToRender = allModes;

            if (state.visualizationMode === 'chord') {
                // Filter: Only allow 7-note diatonic scales in Chord View
                modesToRender = allModes.filter(([id, mode]) => 
                    mode.isDiatonic && mode.intervals.length === 7
                );
                
                // If the current mode is a filtered-out one (like pentatonic), reset to 'major'
                const currentModeExists = modesToRender.some(([id]) => id === state.currentModeId);
                if (!currentModeExists) {
                     state.currentModeId = 'major';
                     state.currentDegree = 1; 
                }
            }
            
            select.innerHTML = modesToRender.map(([id, mode]) => 
                `<option value="${id}" ${id === state.currentModeId ? 'selected' : ''}>${mode.name}</option>`
            ).join('');
        }
        
        /**
         * Updates the Chord View and Scale View buttons with Tailwind classes for blue active state.
         */
        function renderVisualizationModeButtons() {
            const isChord = state.visualizationMode === 'chord';
            
            const chordBtn = document.getElementById('mode-chord-btn');
            const scaleBtn = document.getElementById('mode-scale-btn');

            // Classes for the ACTIVE (blue) state
            const activeClasses = ['bg-blue-700', 'text-white', 'shadow-lg', 'ring-2', 'ring-blue-300', 'border-blue-700'];
            
            // Classes for the INACTIVE (gray/white) state
            const inactiveClasses = ['bg-white', 'text-gray-700', 'hover:bg-gray-200', 'border-gray-300', 'shadow-sm'];

            const updateButton = (btn, isActive) => {
                if (!btn) return;
                
                // Toggle active classes
                activeClasses.forEach(cls => btn.classList.toggle(cls, isActive));
                
                // Toggle inactive classes
                inactiveClasses.forEach(cls => btn.classList.toggle(cls, !isActive));
            };

            updateButton(chordBtn, isChord);
            updateButton(scaleBtn, !isChord);
        }

        function renderChordButtons() {
            const container = document.getElementById('chord-buttons-container');
            const mode = getCurrentMode();
            const qualities = mode.qualities;
            const triadQualities = mode.triadQualities;
            
            const numDegrees = mode.degrees; 
            const isScaleView = state.visualizationMode === 'scale';
            
            const canInvert = mode.isDiatonic && mode.intervals.length === 7 && state.visualizationMode === 'chord' && state.currentDegree !== 8;

            // Adjust grid layout dynamically
            container.classList.remove('sm:grid-cols-7', 'sm:grid-cols-5', 'sm:grid-cols-8');
            // Using grid-cols-4 and sm:grid-cols-8 (desktop)
            container.classList.add(numDegrees === 8 ? 'sm:grid-cols-8' : 'sm:grid-cols-5');


            container.innerHTML = mode.qualities.slice(0, numDegrees).map((romanNumeral, index) => {
                const degree = index + 1;
                const isActive = degree === state.currentDegree;
                
                const qualityIndex = index; 
                const isInvrted = isActive && state.currentInversion > 0; // Flag for inverted state

                let inversionSuffix = '';
                let qualityDisplay = '';
                let mainButtonText = '';
                let secondaryButtonText = '';
                
                if (isScaleView) {
                    // SCALE VIEW: Use simple Arabic numeral (1, 2, 3...)
                    mainButtonText = degree.toString(); 
                } else {
                    // CHORD VIEW: Use Roman numeral and chord quality/inversion
                    mainButtonText = romanNumeral;
                    qualityDisplay = mode.isDiatonic && mode.intervals.length === 7 ? triadQualities[qualityIndex] : '';
                    
                    if (isActive && degree <= 7 && canInvert && state.currentInversion > 0) {
                         // Use common figured bass shorthand for display on the buttons
                         inversionSuffix = state.currentInversion === 1 ? ' / 6' : ' / 6/4';
                    }
                    secondaryButtonText = `${qualityDisplay}${inversionSuffix}`;
                }
                
                let buttonClasses = 'bg-gray-100 text-gray-700 hover:bg-gray-300 shadow-sm';

                if (isActive && !isInvrted) {
                    // Active, Root Position
                    buttonClasses = 'bg-blue-700 text-white ring-4 ring-blue-300 transform scale-105 shadow-xl';
                } else if (isInvrted) {
                    // Active, INVERTED Position: Use strong contrasting style (Indigo + Yellow ring)
                    buttonClasses = 'bg-indigo-600 text-white ring-4 ring-yellow-400 transform scale-105 shadow-2xl border-2 border-white';
                }


                return `
                    <button onclick="handleDegreeChange(${degree})"
                            class="py-3 px-2 rounded-lg font-extrabold transition duration-200 
                            flex flex-col items-center justify-center min-h-20
                            ${buttonClasses}"> 
                        <span class="text-xl">${mainButtonText}</span>
                        <span class="text-xs font-medium opacity-80">${secondaryButtonText}</span>
                    </button>
                `;
            }).join('');
        }

        /**
         * Renders the combined key/mode and chord/note info into the staff header.
         */
        function renderStaffHeader() {
            const headerElement = document.getElementById('staff-header-text');
            if (!headerElement) return;

            const detailedText = getDetailedHighlightName(); // e.g., "CMaj (I) / 6" or "C (1)"
            const keyModeText = getSimplifiedKeyName(); // e.g., "C Ionian"

            // Combine into a concise format: Key Mode | Chord/Note Info
            // Example: C Ionian | CMaj (I) / 6
            const displayString = `${keyModeText} | ${detailedText}`;
            
            headerElement.textContent = displayString;
        }
        
        // --- HANDLERS ---
        
        function updateUI() {
            // Renders mode select and handles scale filtering/resetting state.currentModeId if needed
            renderModeSelect(); 

            const mode = getCurrentMode();
            
            // Check for degree bounds
            if (state.currentDegree > mode.degrees) {
                state.currentDegree = 1;
            }
            
            // Check for inversion validity
            const canInvert = mode.isDiatonic && mode.intervals.length === 7 && state.visualizationMode === 'chord' && state.currentDegree !== 8;
            
            if (!canInvert) {
                state.currentInversion = 0;
            }

            // Step 1: Calculate the initial 'preferred' MIDI notes for the key/degree/inversion.
            let rawMidiNotes;
            if (state.visualizationMode === 'chord') {
                rawMidiNotes = calculateChordMidiNotes(
                    state.currentKeyIndex, 
                    state.currentDegree,
                    state.currentInversion 
                );
            } else { // 'scale' mode
                rawMidiNotes = calculateSingleScaleMidiNote(
                    state.currentKeyIndex, 
                    state.currentDegree
                );
            }

            // Step 2: Transpose the raw notes to fit the selected staff's range.
            // This transposed set is the FINAL MIDI NOTES used for BOTH the staff and the keyboard.
            let finalMidiNotes;
            if (state.currentClef === 'treble') {
                finalMidiNotes = calculateTrebleClefNotes(rawMidiNotes);
            } else if (state.currentClef === 'bass') {
                finalMidiNotes = calculateBassClefNotes(rawMidiNotes);
            } else {
                 finalMidiNotes = rawMidiNotes;
            }
            
            state.highlightedMidiNotes = finalMidiNotes;
            
            state.highlightedPitchClasses = state.highlightedMidiNotes.map(midi => midi % 12);
            
            // Render UI components
            renderKeySelect();
            renderChordButtons();
            renderStaffHeader(); // Updates the consolidated header text
            renderStepVisualizer(); 
            renderVisualizationModeButtons(); // Updates button active states
            drawKeyboard(); 
            drawSheetMusic(); 
        }

        function handleKeyChange(keyName) {
            state.currentKeyName = keyName;
            state.currentKeyIndex = KEY_TO_PITCH_CLASS[keyName];

            state.currentDegree = 1; 
            state.currentInversion = 0; 
            updateUI();
        }

        function handleModeChange(modeId) {
            state.currentModeId = modeId;
            state.currentDegree = 1; 
            state.currentInversion = 0; 
            updateUI();
        }
        
        function handleClefChange(clef) {
            state.currentClef = clef;
            updateUI();
        }

        function handleDegreeChange(degree) {
            const mode = getCurrentMode();
            
            const canInvert = mode.isDiatonic && mode.intervals.length === 7 && state.visualizationMode === 'chord' && degree !== 8;

            if (degree === state.currentDegree) {
                if (canInvert) {
                    // Cycle inversion if already selected
                    state.currentInversion = (state.currentInversion + 1) % 3; 
                } else {
                    state.currentInversion = 0;
                }
            } else {
                state.currentDegree = degree;
                state.currentInversion = 0; 
            }
            updateUI();
        }

        function handleVisualizationModeChange(mode) {
            state.visualizationMode = mode;
            state.currentInversion = 0; 
            updateUI();
        }
        
        // --- PWA Registration (Existing functionality) ---
        function registerPwa() {
            // Note: Keeping this for potential desktop PWA installation, but the core PWA 
            // experience is not tied to the viewport meta tag.
            const manifestContent = {
                "name": "TheoryViz",
                "short_name": "TheoryViz",
                "start_url": ".",
                "display": "standalone",
                "background_color": "#ffffff",
                "theme_color": "#3b82f6",
                "icons": [
                    {"src": "https://placehold.co/192x192/3b82f6/ffffff?text=TV", "sizes": "192x192", "type": "image/png"},
                    {"src": "https://placehold.co/512x512/3b82f6/ffffff?text=TV", "sizes": "512x512", "type": "image/png"}
                ]
            };

            const manifestBlob = new Blob([JSON.stringify(manifestContent)], {type : 'application/json'});
            const manifestUrl = URL.createObjectURL(manifestBlob);
            
            const link = document.createElement('link');
            link.rel = 'manifest';
            link.href = manifestUrl;
            document.head.appendChild(link);
        }
        // --- APPLICATION STARTUP ---
        
        window.onload = () => {
             // Re-initialize PIANO_KEY_DATA for the full 88-key range
             PIANO_KEY_DATA.length = 0;
             for (let i = START_MIDI; i <= END_MIDI; i++) {
                 PIANO_KEY_DATA.push({
                     midi: i,
                     pitchClass: i % 12,
                     name: KEYS[i % 12],
                     isWhite: MAJOR_INTERVALS.includes(i % 12),
                 });
             }

             // Initialize the UI elements and draw the first state
             updateUI();
             
             // Register PWA for installation capability
             registerPwa();

             // Initial scroll to center on the default C4 key (MIDI 60) for a good starting view
             const pianoContainer = document.getElementById('piano-container');
             if (pianoContainer) {
                const c4Center = getKeyCenterX(60); 
                const scrollX = c4Center - (pianoContainer.offsetWidth / 2);
                pianoContainer.scroll({ left: scrollX, behavior: 'instant' }); 
             }

        };
    </script>
</body>
</html>
