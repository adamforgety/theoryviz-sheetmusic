<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TheoryViz</title>
    <meta name="theme-color" content="#3b82f6">
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.0.3/build/cjs/vexflow.js"></script>
    
    <style>
        /* Custom styles for the SVG keyboard container */
        .keyboard-container {
            position: relative;
            /* Height remains 250px to accommodate the step visualizer track */
            height: 250px; 
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            /* Light gray for contrast against the white keys */
            background-color: #f3f4f6;
            overflow-x: scroll; /* KEEP scroll to allow the fixed width content to be scrolled */
            overscroll-behavior: contain; /* Prevents unwanted browser scroll on mobile drag */
        }

        /* Hide scrollbar for a cleaner look, while still allowing scroll */
        .keyboard-container::-webkit-scrollbar {
            display: none;
        }
        .keyboard-container {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* Highlighting Styles for a consistent look with the buttons */
        .highlight-transition {
            transition: fill 0.2s ease;
        }
        
        /* Custom style for visualization buttons (Removed .active style to use pure Tailwind in JS) */
        .viz-btn {
            border-radius: 0.5rem;
            transition: all 0.2s;
            font-weight: 600; /* font-semibold */
            padding-top: 0.625rem; /* py-2.5 */
            padding-bottom: 0.625rem; /* py-2.5 */
            border-width: 1px; /* Ensure border is present for both states */
        }
        
        /* Style the VexFlow container to ensure it looks good */
        /* Set a height for the single staff container */
        #staff-display-single {
            min-height: 140px; 
        }
        
        /* Ensures the canvas/svg element from VexFlow doesn't look bad */
        #staff-display-single > svg {
            display: block;
            margin: 0 auto;
        }

    </style>
</head>
<body class="bg-gray-50 font-sans p-8"> <div class="max-w-6xl mx-auto bg-white rounded-xl shadow-2xl p-10"> <h1 class="text-4xl font-extrabold text-gray-800 mb-3 text-center"> TheoryViz
        </h1>
        <p class="text-center text-gray-600 mb-6">
            Visualize harmony anywhere!
        </p>

        <div class="p-4 bg-gray-100 rounded-xl mb-6 shadow-inner border border-gray-200">
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4"> 
            
                <div>
                    <label for="key-select" class="block text-xs font-medium text-gray-700 mb-1">Root Key</label>
                    <select id="key-select" onchange="handleKeyChange(event.target.value)"
                            class="w-full p-2 border border-gray-300 rounded-lg bg-white text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                        <option value="C">C</option>
                        <option value="G">G</option>
                        <option value="D">D</option>
                        <option value="A">A</option>
                        <option value="E">E</option>
                        <option value="B">B</option>
                        <option value="F#">F#</option>
                        <option value="C#">C#</option>
                        <option value="F">F</option>
                        <option value="Bb">Bb</option>
                        <option value="Eb">Eb</option>
                        <option value="Ab">Ab</option>
                        <option value="Db">Db</option>
                        <option value="Gb">Gb</option>
                        <option value="Cb">Cb</option>
                    </select>
                </div>

                <div>
                    <label for="mode-select" class="block text-xs font-medium text-gray-700 mb-1">Scale Type</label>
                    <select id="mode-select" onchange="handleModeChange(event.target.value)"
                            class="w-full p-2 border border-gray-300 rounded-lg bg-white text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                            <option value="major">Major</option>
                            <option value="minor">Natural Minor</option>
                            <option value="dorian">Dorian</option>
                        </select>
                </div>
                
                <div id="accidental-switch-container">
                    </div>

            </div>
            
            <div class="grid grid-cols-2 gap-4 mt-4"> 
                <button id="mode-chord-btn" onclick="handleVisualizationModeChange('chord')"
                        class="viz-btn w-full text-base bg-gray-200 border-gray-300 text-gray-800"> Chord View
                </button>
                
                <button id="mode-scale-btn" onclick="handleVisualizationModeChange('scale')"
                        class="viz-btn w-full text-base bg-blue-500 text-white border-blue-600"> Scale View
                </button>
            </div>
            
            <div class="grid grid-cols-2 gap-4 mt-4 border-t pt-4 border-gray-300"> 
                <button id="input-mode-theory-btn" onclick="handleInputModeChange('theory')"
                        class="viz-btn w-full text-base bg-blue-500 text-white border-blue-600"> Theory Mode (I, II, III...)
                </button>
                
                <button id="input-mode-keyboard-btn" onclick="handleInputModeChange('keyboard')"
                        class="viz-btn w-full text-base border-gray-300 bg-white text-gray-800"> Keyboard Input
                </button>
            </div>
        </div>
        
        <div class="grid grid-cols-1 lg:grid-cols-1 gap-4 mb-6">
            
            <div id="sheet-music-container" class="p-4 bg-gray-100 border border-gray-300 rounded-xl shadow-inner">
                <div class="flex flex-col justify-between items-start mb-3 border-b pb-2"> 
                    <h2 id="staff-header-text" class="text-lg font-bold text-gray-800 mb-2"> Theory Mode Active
                    </h2> 
                    <div class="flex items-center space-x-3">
                        <label for="clef-select" class="text-sm text-gray-700 font-medium">Clef:</label>
                        <select id="clef-select" onchange="handleClefChange(event.target.value)"
                                class="p-1 border border-gray-300 rounded-lg bg-white text-gray-800 text-sm focus:ring-blue-500 focus:border-blue-500 shadow-sm transition">
                            <option value="treble">Treble</option>
                            <option value="bass">Bass</option>
                        </select>
                    </div>
                </div>
                <div id="staff-display-single" class="w-full overflow-x-scroll min-h-[140px]">
                </div>
            </div>

        </div>
        
        <div id="piano-container" class="keyboard-container overflow-x-scroll pb-4 mt-4">
            <div id="step-visualizer-track" style="width: 3120px; position: relative; height: 30px;" class="mt-1 mb-1">
                </div>
            <svg id="piano-keyboard-svg" width="100%" height="200" preserveAspectRatio="xMinYMin slice"></svg>
        </div>
        
        <div class="mt-4 mb-6 py-3 px-4 bg-yellow-100 border-2 border-yellow-400 text-yellow-800 text-sm rounded-lg text-center font-bold shadow-md">
            Click the <span class="text-blue-700 font-extrabold">ACTIVE</span> Roman numeral to cycle <span class="text-indigo-700">INVERSIONS</span> (Root, 1st, 2st) in Chord View.
        </div>

        <div id="chord-buttons-container" class="grid grid-cols-8 gap-3">
             <button class="viz-btn w-full text-base border-gray-300 bg-white text-gray-800" onclick="handleChordButtonClick(1)">I</button>
             <button class="viz-btn w-full text-base border-gray-300 bg-white text-gray-800" onclick="handleChordButtonClick(2)">ii</button>
             <button class="viz-btn w-full text-base border-gray-300 bg-white text-gray-800" onclick="handleChordButtonClick(3)">iii</button>
             <button class="viz-btn w-full text-base border-gray-300 bg-white text-gray-800" onclick="handleChordButtonClick(4)">IV</button>
             <button class="viz-btn w-full text-base border-gray-300 bg-white text-gray-800" onclick="handleChordButtonClick(5)">V</button>
             <button class="viz-btn w-full text-base border-gray-300 bg-white text-gray-800" onclick="handleChordButtonClick(6)">vi</button>
             <button class="viz-btn w-full text-base border-gray-300 bg-white text-gray-800" onclick="handleChordButtonClick(7)">viiÂ°</button>
             <button class="viz-btn w-full text-base border-gray-300 bg-white text-gray-800" onclick="handleChordButtonClick(8)">VIII</button>
        </div>
        
    </div>

    <script>
        // --- VEXFLOW ALIASES ---
        const { Renderer, Stave, StaveNote, Voice, Formatter, Accidental } = Vex.Flow;

        // --- CONSTANTS AND MAPPING ---
        
        const KEY_COMBO_NAMES = [
            "C", "C#/Db", "D", "D#/Eb", "E", 
            "F", "F#/Gb", "G", "G#/Ab", "A", 
            "A#/Bb", "B"
        ];
        
        const KEY_TO_PITCH_CLASS = {
            "C": 0, "C#/Db": 1, "D": 2, "D#/Eb": 3, "E": 4, 
            "F": 5, "F#/Gb": 6, "G": 7, "G#/Ab": 8, "A": 9, 
            "A#/Bb": 10, "B": 11
        };
        
        const KEYS = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const MAJOR_INTERVALS = [0, 2, 4, 5, 7, 9, 11]; // White keys on the piano (C Major)
        
        // Simplified mapping for all 12 pitch classes to a default note name and an accidental (if any)
        // This is crucial for correctly drawing notes clicked by the user, ignoring the current key signature.
        const MIDI_TO_VF_NAME = [
            { note: 'c', acc: 'n' }, // 0: C (natural)
            { note: 'c', acc: '#' }, // 1: C#
            { note: 'd', acc: 'n' }, // 2: D (natural)
            { note: 'd', acc: '#' }, // 3: D#
            { note: 'e', acc: 'n' }, // 4: E (natural)
            { note: 'f', acc: 'n' }, // 5: F (natural)
            { note: 'f', acc: '#' }, // 6: F#
            { note: 'g', acc: 'n' }, // 7: G (natural)
            { note: 'g', acc: '#' }, // 8: G#
            { note: 'a', acc: 'n' }, // 9: A (natural)
            { note: 'a', acc: '#' }, // 10: A#
            { note: 'b', acc: 'n' }, // 11: B (natural)
        ];

        // --- CORE STATE ---
        let currentInputMode = 'theory'; // 'theory' or 'keyboard'
        let currentVisualizationMode = 'scale'; // 'chord' or 'scale'
        let currentClef = 'treble'; 
        let currentKey = 'C'; 
        let currentMode = 'major';
        let userSelectedPitches = []; // Array of MIDI note numbers selected by the user (MIDI 60 = C4)

        // --- KEYBOARD CONSTANTS ---
        const START_MIDI = 21; // A0
        const END_MIDI = 108; // C8 (88 keys)
        const WHITE_KEY_WIDTH = 25;
        const WHITE_KEY_HEIGHT = 180;
        const BLACK_KEY_WIDTH = 15;
        const BLACK_KEY_HEIGHT = 120;
        const BLACK_KEY_OFFSET = 17.5; 
        
        // Calculate the total width based on the number of white keys
        const numWhiteKeys = PIANO_KEY_DATA.filter(k => k.isWhite).length;
        const KEYBOARD_WIDTH = (numWhiteKeys * WHITE_KEY_WIDTH) + 20; // Add some padding

        const PIANO_KEY_DATA = [];

        // --- HELPER FUNCTIONS ---
        
        // Function to determine the center X position of a white key or approximate center of black key
        function getKeyCenterX(midi) {
             let whiteKeyIndex = 0;
             for (let i = START_MIDI; i < midi; i++) {
                 if (MAJOR_INTERVALS.includes(i % 12)) {
                     whiteKeyIndex++;
                 }
             }

             if (MAJOR_INTERVALS.includes(midi % 12)) {
                 // White key center
                 return (whiteKeyIndex * WHITE_KEY_WIDTH) + (WHITE_KEY_WIDTH / 2);
             } else {
                 // Black key: approximate center based on the white key to its left
                 const x = (whiteKeyIndex - 1) * WHITE_KEY_WIDTH + BLACK_KEY_OFFSET + (BLACK_KEY_WIDTH / 2);
                 return x;
             }
         }

        /**
         * Converts a MIDI number to a VexFlow key string and an Accidental object.
         * @param {number} midi - The MIDI note number (0-127).
         * @returns {{keyString: string, accidental: string | null, pitchName: string}}
         */
        function midiToVexFlow(midi) {
            const pitchClass = midi % 12;
            // MIDI 60 (C4) is 'c/4' in VexFlow, so Octave is floor(60/12) - 1 = 4
            const octave = Math.floor(midi / 12) - 1; 

            const { note, acc } = MIDI_TO_VF_NAME[pitchClass];
            const keyString = `${note}/${octave}`;
            const pitchName = `${note.toUpperCase()}${acc === 'n' ? '' : acc}${octave}`; 
            
            return { keyString, accidental: acc, pitchName };
        }

        /**
         * Rudimentary chord/scale detection logic (as requested by user "viewer will show you what chord was built")
         * @param {number[]} pitches - Sorted array of MIDI notes.
         */
        function detectAndNameChord(pitches) {
             if (pitches.length === 0) {
                 return "Input Mode: Click a key on the piano keyboard below.";
             }
             
             // Get unique pitch classes relative to the lowest note played
             const rootMidi = pitches[0];
             const rootPitchClass = rootMidi % 12;
             const uniquePitchClasses = [...new Set(pitches.map(midi => midi % 12))].sort((a,b) => a - b);
             
             const intervals = uniquePitchClasses.map(pc => (pc - rootPitchClass + 12) % 12).sort((a,b) => a - b);
             
             // Remove 0 from intervals array for easy comparison
             const chordIntervals = intervals.filter(i => i !== 0);

             const rootName = KEYS[rootPitchClass];
             
             // Triad Detection (Root, M3/m3, P5)
             if (chordIntervals.length === 2) {
                 const [i1, i2] = chordIntervals;
                 
                 // Major Triad: M3 (4), P5 (7)
                 if (i1 === 4 && i2 === 7) {
                     return `Chord Built: ${rootName} Major Triad!`;
                 }
                 // Minor Triad: m3 (3), P5 (7)
                 if (i1 === 3 && i2 === 7) {
                     return `Chord Built: ${rootName} Minor Triad`;
                 }
                 // Diminished Triad: m3 (3), d5 (6)
                 if (i1 === 3 && i2 === 6) {
                     return `Chord Built: ${rootName} Diminished Triad`;
                 }
             }
             
             // Single Note Feedback
             if (pitches.length === 1) {
                 return `Selected Note: ${midiToVexFlow(pitches[0]).pitchName}`;
             }
             
             // General Feedback
             return `Pitches Selected: ${pitches.map(midi => midiToVexFlow(midi).pitchName).join(', ')}`;
        }

        // --- EVENT HANDLERS (EXISTING MODIFIED) ---

        function handleClefChange(newClef) {
            currentClef = newClef;
            updateKeyboardAndStaff(); 
        }

        function handleVisualizationModeChange(mode) {
            currentVisualizationMode = mode;
            
            // Update button styles
            document.getElementById('mode-chord-btn').className = mode === 'chord' ? 'viz-btn w-full text-base bg-blue-500 text-white border-blue-600' : 'viz-btn w-full text-base bg-gray-200 border-gray-300 text-gray-800';
            document.getElementById('mode-scale-btn').className = mode === 'scale' ? 'viz-btn w-full text-base bg-blue-500 text-white border-blue-600' : 'viz-btn w-full text-base bg-gray-200 border-gray-300 text-gray-800';
            
            if (currentInputMode === 'keyboard') {
                 // Re-apply selection rules
                 if (mode === 'scale' && userSelectedPitches.length > 1) {
                    userSelectedPitches = userSelectedPitches.slice(-1); // Keep only the last one
                 }
                updateKeyboardAndStaff();
            } else {
                updateStaff(currentKey, currentMode);
            }
        }
        
        function handleKeyChange(key) {
             currentKey = key;
             if (currentInputMode === 'theory') updateStaff(currentKey, currentMode);
        }
        function handleModeChange(mode) {
             currentMode = mode;
             if (currentInputMode === 'theory') updateStaff(currentKey, currentMode);
        }

        function handleChordButtonClick(chordIndex) {
            if (currentInputMode === 'keyboard') return; // Deactivate in keyboard mode
            // Existing logic to select chord and redraw staff (omitted for brevity, but a mock is in drawTheoryNotes)
            // In a real app, this would select the notes for the roman numeral and redraw the staff.
            updateStaff(currentKey, currentMode);
        }

        // --- NEW INPUT MODE LOGIC ---

        /**
         * Handles the click on an SVG piano key (Keyboard Input Mode).
         * @param {number} midiNote - The MIDI note number of the clicked key.
         */
        function handleKeyClick(midiNote) {
            if (currentInputMode !== 'keyboard') return;

            const index = userSelectedPitches.indexOf(midiNote);
            const isSelected = index !== -1;

            if (currentVisualizationMode === 'scale') {
                // Scale view: Only one note selected at a time
                userSelectedPitches = [midiNote];
            } else if (currentVisualizationMode === 'chord') {
                // Chord view: Toggle selection
                if (isSelected) {
                    userSelectedPitches.splice(index, 1);
                } else {
                    if (userSelectedPitches.length < 10) { 
                        userSelectedPitches.push(midiNote);
                    }
                }
            }
            
            // Sort the pitches to ensure VexFlow draws the notes correctly (lowest to highest)
            userSelectedPitches.sort((a, b) => a - b);
            
            updateKeyboardAndStaff();
        }

        /**
         * Updates the global input mode and modifies UI (buttons, Roman numerals).
         * @param {string} mode - 'theory' or 'keyboard'.
         */
        function handleInputModeChange(mode) {
            currentInputMode = mode;
            
            // Clear user selected notes when switching out of keyboard input to Theory Mode
            if (mode === 'theory') {
                userSelectedPitches = [];
                // Re-trigger the existing TheoryViz logic
                updateStaff(currentKey, currentMode); 
            } else {
                // When switching to keyboard mode, clear and prepare for new input
                userSelectedPitches = []; 
                updateStaff(null, null); // Clear staff or show instruction for input
            }
            
            updateInputModeUI();
            updateKeyboardHighlights();
        }
        
        /**
         * Updates the button styles and disables the Roman numeral buttons when in 'keyboard' mode.
         */
        function updateInputModeUI() {
            const theoryBtn = document.getElementById('input-mode-theory-btn');
            const keyboardBtn = document.getElementById('input-mode-keyboard-btn');
            const chordButtonsContainer = document.getElementById('chord-buttons-container');

            if (currentInputMode === 'theory') {
                theoryBtn.className = 'viz-btn w-full text-base bg-blue-500 text-white border-blue-600';
                keyboardBtn.className = 'viz-btn w-full text-base border-gray-300 bg-white text-gray-800';
                chordButtonsContainer.style.opacity = '1';
                chordButtonsContainer.style.pointerEvents = 'auto';
            } else { // 'keyboard' mode
                theoryBtn.className = 'viz-btn w-full text-base border-gray-300 bg-white text-gray-800';
                keyboardBtn.className = 'viz-btn w-full text-base bg-blue-500 text-white border-blue-600';
                chordButtonsContainer.style.opacity = '0.5';
                chordButtonsContainer.style.pointerEvents = 'none'; // Deactivate Roman numeral buttons
            }
        }
        
        // --- VEXFLOW DRAWING FUNCTIONS ---

        /**
         * Draws the user-selected notes on the staff (Keyboard Input Mode).
         * @param {number[]} pitches - Array of MIDI note numbers.
         * @param {string} clef - 'treble' or 'bass'.
         */
        function drawUserInputNotes(pitches, clef) {
            const container = document.getElementById('staff-display-single');
            const staffHeader = document.getElementById('staff-header-text');
            container.innerHTML = ''; 

            const renderer = new Renderer(container, Renderer.Backends.SVG);
            const context = renderer.getContext();
            context.resize(300, 140);
            
            const stave = new Stave(10, 0, 280).addClef(clef);
            // Draw without a key signature, as accidentals will be explicitly added
            stave.setContext(context).draw();

            if (pitches.length === 0) {
                 staffHeader.textContent = "Input Mode: Click a key on the piano keyboard below.";
                 return;
            }

            const vexFlowKeys = pitches.map(midi => midiToVexFlow(midi).keyString);

            // Create the StaveNote
            const staveNote = new StaveNote({ 
                keys: vexFlowKeys, 
                duration: "w" , 
                clef: clef
            });

            // Add accidentals explicitly (This fulfills the requirement of showing notes on the staff by clicking)
            pitches.forEach((midi, index) => {
                const { accidental } = midiToVexFlow(midi);
                // We add the explicit accidental from our map (e.g., '#', 'b', or 'n' for natural)
                staveNote.addModifier(new Accidental(accidental), index);
            });


            const voice = new Voice({ num_beats: 1, beat_value: 1 }).addTickables([staveNote]);
            new Formatter().joinVoices([voice]).format([voice], 250);

            voice.draw(context, stave);
            
            // Update header to show chord/scale name
            staffHeader.textContent = detectAndNameChord(pitches); 
        }
        
        /**
         * Mock function for Theory Mode staff drawing.
         * @param {string} key - Root key (e.g., 'C').
         * @param {string} mode - Scale mode (e.g., 'major').
         */
        function drawTheoryNotes(key, mode) {
             const container = document.getElementById('staff-display-single');
             const staffHeader = document.getElementById('staff-header-text');
             container.innerHTML = '';
             
             const renderer = new Renderer(container, Renderer.Backends.SVG);
             const context = renderer.getContext();
             context.resize(300, 140);
             
             // Theory Mode: Draw C Major Scale or Chord for example
             const stave = new Stave(10, 0, 280).addClef(currentClef).addKeySignature(key);
             stave.setContext(context).draw();
             
             // Use a simple C Major chord/scale as a placeholder for the Theory Mode visualization
             const chordKeys = ["c/4", "e/4", "g/4"];
             const scaleKeys = ["c/4", "d/4", "e/4", "f/4", "g/4", "a/4", "b/4"];
             
             const keysToDraw = (currentVisualizationMode === 'chord') ? chordKeys : scaleKeys;
             const duration = (currentVisualizationMode === 'chord') ? "w" : "q";
             const numBeats = (currentVisualizationMode === 'chord') ? 1 : keysToDraw.length;
             
             const notes = [
                 new StaveNote({ keys: keysToDraw, duration: duration })
             ];
             
             // If a chord, we need to add the accidentals if they are not in the key signature.
             if (currentVisualizationMode === 'chord' && keysToDraw.length > 1) {
                 // Mock: Show a C# diminished triad as an example of adding accidentals
                 if (key === 'C' && mode === 'major' && keysToDraw.toString() === ["c/4", "e/4", "g/4"].toString()) {
                    notes[0].setKeys(["c#/4", "e/4", "g/4"]); // C# E G (not a real C major chord, just a demo)
                    notes[0].addAccidental(0, new Accidental("#"));
                    // In a real app, logic would derive the Roman numeral chord from the key/mode.
                 }
             }

             const voice = new Voice({ num_beats: numBeats, beat_value: 4 }).addTickables(notes);
             new Formatter().joinVoices([voice]).format([voice], 250);
             voice.draw(context, stave);
             
             staffHeader.textContent = `Theory Mode: ${key} ${mode} ${currentVisualizationMode === 'chord' ? 'Chord' : 'Scale'} Mockup`;
        }
        
        /**
         * Main staff drawing function (Decides between Theory and Keyboard Input).
         */
        function updateStaff(key, mode) {
             if (currentInputMode === 'keyboard') {
                 drawUserInputNotes(userSelectedPitches, currentClef);
             } else {
                 drawTheoryNotes(key, mode);
             }
        }
        
        // --- KEYBOARD DRAWING LOGIC ---

        /**
         * Function to redraw the keyboard highlights based on userSelectedPitches.
         */
        function updateKeyboardHighlights() {
            // Remove all existing highlights
            document.querySelectorAll('.key-highlight-rect').forEach(el => el.remove());
            
            if (currentInputMode !== 'keyboard' || userSelectedPitches.length === 0) return;

            const svg = document.getElementById('piano-keyboard-svg');
            const namespace = "http://www.w3.org/2000/svg";
            
            userSelectedPitches.forEach(midiNote => {
                const keyElement = document.getElementById(`key-${midiNote}`);
                if (keyElement) {
                    const isWhite = (keyElement.getAttribute('fill') === '#ffffff');
                    
                    const highlight = document.createElementNS(namespace, 'rect');
                    
                    highlight.setAttribute('x', keyElement.getAttribute('x'));
                    highlight.setAttribute('y', keyElement.getAttribute('y'));
                    highlight.setAttribute('width', keyElement.getAttribute('width'));
                    highlight.setAttribute('height', keyElement.getAttribute('height'));
                    highlight.setAttribute('fill', isWhite ? '#3b82f6' : '#2563eb'); 
                    highlight.setAttribute('opacity', '0.7');
                    highlight.setAttribute('pointer-events', 'none'); 
                    highlight.setAttribute('class', 'key-highlight-rect highlight-transition');
                    
                    // The highlight must be added after the key for proper z-order
                    // We re-append the key to bring it to the front of the highlight
                    svg.appendChild(highlight);
                    svg.appendChild(keyElement); 
                }
            });
        }
        
        /**
         * Main function to re-render keyboard highlights and staff.
         */
        function updateKeyboardAndStaff() {
             updateKeyboardHighlights();
             updateStaff(currentKey, currentMode);
             updateInputModeUI(); // Update Roman numeral button status
        }
        
        /**
         * Draws the full 88-key piano keyboard.
         */
        function drawPianoKeyboard() {
            const svg = document.getElementById('piano-keyboard-svg');
            const namespace = "http://www.w3.org/2000/svg";
            svg.setAttribute('width', KEYBOARD_WIDTH);
            svg.innerHTML = ''; 
            
            let whiteKeyIndex = 0;
            const whiteKeys = [];
            const blackKeys = [];

            // 1. Populate PIANO_KEY_DATA
            PIANO_KEY_DATA.length = 0;
            for (let i = START_MIDI; i <= END_MIDI; i++) {
                const isWhite = MAJOR_INTERVALS.includes(i % 12);
                PIANO_KEY_DATA.push({
                    midi: i,
                    pitchClass: i % 12,
                    isWhite: isWhite,
                });
            }
            
            // 2. Create the SVG elements
            PIANO_KEY_DATA.forEach(keyData => {
                const midi = keyData.midi;
                const isWhite = keyData.isWhite;
                const keyElement = document.createElementNS(namespace, 'rect');
                
                keyElement.setAttribute('id', `key-${midi}`);
                keyElement.setAttribute('data-midi', midi);
                keyElement.setAttribute('class', 'highlight-transition cursor-pointer');

                if (isWhite) {
                    const x = whiteKeyIndex * WHITE_KEY_WIDTH;
                    keyElement.setAttribute('x', x);
                    keyElement.setAttribute('y', 30);
                    keyElement.setAttribute('width', WHITE_KEY_WIDTH);
                    keyElement.setAttribute('height', WHITE_KEY_HEIGHT);
                    keyElement.setAttribute('fill', '#ffffff');
                    keyElement.setAttribute('stroke', '#ccc');
                    whiteKeys.push(keyElement);
                    whiteKeyIndex++;
                } else {
                    const x = (whiteKeyIndex - 1) * WHITE_KEY_WIDTH + BLACK_KEY_OFFSET; 
                    keyElement.setAttribute('x', x);
                    keyElement.setAttribute('y', 30);
                    keyElement.setAttribute('width', BLACK_KEY_WIDTH);
                    keyElement.setAttribute('height', BLACK_KEY_HEIGHT);
                    keyElement.setAttribute('fill', '#000000');
                    blackKeys.push(keyElement);
                }
                
                // ADD CLICK LISTENER: Core implementation for user interaction
                keyElement.addEventListener('click', () => handleKeyClick(midi));
            });
            
            // 3. Draw white keys first, then black keys for proper z-order
            whiteKeys.forEach(key => svg.appendChild(key));
            blackKeys.forEach(key => svg.appendChild(key));
            
            updateKeyboardHighlights();
        }

        // --- APPLICATION STARTUP ---
        
        window.onload = () => {
             // 1. Draw the keyboard with click listeners
             drawPianoKeyboard();
             
             // 2. Initialize the UI elements and draw the first state (Default to Theory Mode)
             updateInputModeUI();
             updateStaff(currentKey, currentMode);

             // 3. Initial scroll to center on the default C4 key (MIDI 60) for a good starting view
             const pianoContainer = document.getElementById('piano-container');
             if (pianoContainer) {
                const c4Center = getKeyCenterX(60); 
                const scrollX = c4Center - (pianoContainer.offsetWidth / 2);
                pianoContainer.scroll({ left: scrollX, behavior: 'instant' }); 
             }
             
             // 4. Mock setting initial button styles
             handleVisualizationModeChange(currentVisualizationMode);

             // registerPwa() would go here
        };
    </script>
</body>
</html>
